# 线性时间复杂度的排序算法

> 学习曲线：★★★

## 桶排序（Bucket sort）

### 桶排序的核心思想

* **核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的。**

![[桶排序.png]]

### 桶排序的时间复杂度

* **桶排序的时间复杂度是 `O(n)`.**
* 假设要排序的数据有 n 个，我们把它们均匀分到 m 个桶内，每个桶里就有 `k = n / m` 个元素。对每个桶使用快速排序，则每个桶的时间复杂度为 `O(klogk)`. m 个桶的时间复杂度就是 `O(m * klogk)`. 换算可以得到 `O(m * (n/m)log(n/m))`. 简化后得到 `O(n * log(n/m))`. 当桶的个数 m 接近数据个数 n 时，`log(n/m)` 的值就接近一个很小的常量。忽略这个系数，这时桶排序的时间复杂度就可以认为是 `O(n)`.

### 桶排序的应用场景

* 桶排序的时间复杂度虽然很优秀，但它对数据也有着很高的要求。
	* 首先，*排序数据要很容易地分成 m 个桶，并且桶与桶之间有着大小顺序之分。* 这样每个桶内的数据都排序完之后，桶之间的数据不需要再进行排序。
	* 其次，*数据在每个桶之间的分布是比较均匀的。* 如果数据在划分之后，有些桶内的数据非常多，另一些非常少，则桶内排序的时间复杂度就不是常量级。甚至极端情况下，所有数据都被分到一个桶里，时间复杂度就退化为 `O(nlogn)` 了。
* **桶排序比较适合用在外部排序中。** 比如数据存储在外部磁盘中，数据量较大，而当前内存有限，无法将数据全部加载到内存中。

#### 实际案例

* 比如我们有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是我们的内存有限，只有几百MB，没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办呢？
* 这时就可以借助桶排序的处理思想来解决这个问题。
* 我们可以先扫描一遍文件，看订单金额所处的数据范围。假设经过扫描之后我们得到，订单金额最小是 1 元，最大是 10 万元。我们将所有订单根据金额划分到 100 个桶里，第一个桶我们存储金额在 1 元到 1000 元之内的订单，第二桶存储金额在 1001 元到 2000 元之内的订单，以此类推。每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名（00，01，02...99）。
* 理想的情况下，如果订单金额在 1 到 10 万之间均匀分布，那订单会被均匀划分到 100 个文件中，每个小文件中存储大约 100MB 的订单数据，我们就可以将这 100 个小文件依次放到内存中，用快排来排序。等所有文件都排好序之后，只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中，那这个文件中存储的就是按照金额从小到大排序的订单数据了。
* 不过，订单按照金额在 1 元到 10 万元之间并不一定是均匀分布的 ，所以 10GB 订单数据是无法均匀地被划分到 100 个文件中的。有可能某个金额区间的数据特别多，划分之后对应的文件就会很大，没法一次性读入内存。这又该怎么办呢？
* 针对这些划分之后还是比较大的文件，其实可以继续划分，比如，订单金额在 1 元到1000 元之间的比较多，我们就将这个区间继续划分为 10 个小区间，1 元到 100 元，101 元到 200 元，201 元到 300 元....901 元到 1000 元。如果划分之后，101 元到 200 元之间的订单还是太多，无法一次性读入内存，那就继续再划分，直到所有的文件都能读入内存为止。

## 计数排序（Counting sort）

* **计数排序其实是桶排序的一种特殊情况**。比如最大值是 k，就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，这样就省掉了桶内排序的时间。

### 计数排序的核心思想

* 考生的满分是 900 分，最小是0分，这个数据的范围很小，所以我们可以分成 901 个桶，对应分数从 0 分到 900 分。根据考生的成绩，我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是 `O(n)`。
* 可以简单理解为，**用数据规模的大小作为数组的区间，把数据值当成索引，用以存放各个值出现的次数来当成参照进行排序操作。**
* 应用场景：**排序的数据远远大于数据区间的场景。但数据区间是整数或者能够比较方便的转成整数。**
	* 例如高考分数排名。

#### 案例说明

* 假设只有 8 个考生，分数在 0 到 5 分之间。这 8 个考生的成绩我们放在一个数组 `A[8]` 中，它们分别是：`2, 5, 3, 0, 2, 3, 0, 3`。
* 考生的成绩从 0 到 5 分，我们使用大小为6的数组 `C[6]` 表示桶，其中下标对应分数。不过，*`C[6]` 内存储的并不是考生，而是对应的考生个数*。像刚才举的例子，我们只需要遍历一遍考生分数，就可以得到 `C[6]` 的值。

![[计数排序过程一.png]]

* 从图中可以看出，分数为 3 分的考生有 3 个，小于 3 分的考生有 4 个，所以，成绩为 3 分的考生在排序之后的有序数组 `R[8]` 中，会保存下标 4，5，6 的位置。

![[计数排序过程二.png]]

* 思路是这样的：我们对 `C[6]` 数组顺序求和，`C[6]` 存储的数据就变成了下面这样子。**`C[k]` 数组里存储着小于等于分数 k 的考生个数**。

![[计数排序过程三.png]]

* **我们从后到前依次扫描数组 A。比如，当扫描到 3 时，我们可以从数组 C 中取出下标为 3 的值 7，也就是说，到目前为止，包括自己在内，分数小于等于 3 的考生有7个，也就是说 3 是数组 R 中的第 7 个元素（也就是数组 R 中下标为 6 的位置）。当 3 放入到数组 R 中后，小于等于 3 的元素就只剩下了 6 个，所以相应的 `C[3]` 要减 1，变成 6。**
* 以此类推，当我们扫描到第 2 个分数为 3 的考生的时候，就会把它放入数组 R 中的第 6 个元素的位置（也就是下标为 5 的位置）。当我们扫描完整个数组 A 后，数组 R 内的数据就是按照分数从小到大有序排列的。

![[计数排序过程四.png]]

### 计数排序的具体实现

* 梳理上面所讲述的排序思想如下：
	* **首先遍历数组，得到一个索引和原数组的元素值对应的索引数组；**
	* **其次，我们把这个索引数组的项累加，得到就是在当前索引（*元素值*）位置，小于等于当前索引值的元素的个数（*也可以理解为排位顺序*）；** 
	* **然后，遍历原数组，在对应的索引位置得到原数组的元素值所对应的位置（*排位顺序*），每记录一次，就更新一次累加数组中的值（*也就是小于等于当前元素的个数*），实际操作就是减一；**
	* **最终依次执行后，最终就能得到排好序的数组。**
* 下面是原文中的 Java 实现，仅供参考。

```java
// 计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。
public void countingSort(int[] a, int n) {
  if (n <= 1) return;

  // 查找数组中数据的范围
  int max = a[0];
  for (int i = 1; i < n; ++i) {
    if (max < a[i]) {
      max = a[i];
    }
  }

  int[] c = new int[max + 1]; // 申请一个计数数组c，下标大小[0,max]
  for (int i = 0; i <= max; ++i) {
    c[i] = 0;
  }

  // 计算每个元素的个数，放入c中
  for (int i = 0; i < n; ++i) {
    c[a[i]]++;
  }

  // 依次累加
  for (int i = 1; i <= max; ++i) {
    c[i] = c[i-1] + c[i];
  }

  // 临时数组r，存储排序之后的结果
  int[] r = new int[n];
  // 计算排序的关键步骤，有点难理解
  for (int i = n - 1; i >= 0; --i) {
    int index = c[a[i]]-1;
    r[index] = a[i];
    c[a[i]]--;
  }

  // 将结果拷贝给a数组
  for (int i = 0; i < n; ++i) {
    a[i] = r[i];
  }
}
```

#### 计数排序的默认实现

* 这是参照上面的思路实现的计数排序。
	* 核心要理解的是通过累加的值获取对应值的逻辑。
	* 文中实现的思路是从后往前遍历，实际上从前往后也一样可以达到排序的效果。

```typescript
/**
 * @description: 计数排序
 * @param {number[]} arr
 * @return {number[]}
 */
function countingSort(arr: number[]): number[] {
  // 获取数组中的最大值来确认索引数组的长度
  const max = Math.max(...arr) + 1;
  // 设置初始值
  const idxList: number[] = new Array(max).fill(0);
  // 用于保存结果数组
  const res: number[] = [];

  // 索引数组更新内容
  for (let i = 0; i < arr.length; i++) {
    const ele = arr[i];
    idxList[ele]++;
  }

  // 更新累加器，复用索引数组
  for (let j = 1; j < idxList.length; j++) {
    idxList[j] = idxList[j] + idxList[j - 1];
  }

	// !主要理解这里的逻辑
  for (let n = 0; n < arr.length; n++) {
    const ele = arr[n];
    const idx = idxList[ele] - 1;
    // 取到对应索引值所对应的数组元素
    res[idx] = ele;
    idxList[ele]--;
  }

  return res;
}
```

* 让我们添加两行代码来观察运行过程中的日志和结果。

```typescript
console.log(`索引数组 [${idxList}]`);
// 累加器逻辑执行
console.log(`累加器数组 [${idxList}]`);

console.table(countingSort([3, 6, 1, 8, 1, 4, 5, 2, 7]));
```

* 打印出如下的结果。

```shell
索引数组 [0,2,1,1,1,1,1,1,1]
累加器数组 [0,2,3,4,5,6,7,8,9]
┌─────────┬────────┐
│ (index) │ Values │
├─────────┼────────┤
│    0    │   1    │
│    1    │   1    │
│    2    │   2    │
│    3    │   3    │
│    4    │   4    │
│    5    │   5    │
│    6    │   6    │
│    7    │   7    │
│    8    │   8    │
└─────────┴────────┘
```

#### 计数排序的 TS 实现

* 下面是一种简化的实现，但整体核心应该是相似的。
	* **核心就是先确认数据的区间大小，并新建另一个等同这个区间长度大小的数组；**
	* **遍历一遍原数组，将每个数出现的次数直接保存再另一个数组所对应的索引里；**
	* **再遍历一遍另一个数组，依次取出里面索引所对应的值，*重复项记得累加*，最终得到排序后的结果。**
* 这是自己理解的实现，支持 `0 - Number.MAX_SAFE_INTEGER` 这个区间内且为整数的场景。

```typescript
/**
 * @description: 计数排序的简单实现 
 * 时间复杂度 O(n)
 * @param {number[]} arr
 * @return {number[]}
 */
function countingSort(arr: number[]): number[] {
  // 获取待排序数组的最大值，用以获取区间大小
  const maxValue: number = Math.max(...arr);
  // 这里方便实现，默认从 0 开始，因而并没有取最小值
  const cnt: number[] = new Array(maxValue + 1);
  const res = [];

  // 遍历一遍原数组，保存每个值的出现次数在另一个数组的索引位置
  for (let i = 0; i < arr.length; i++) {
    const ele = arr[i];
    cnt[ele] = cnt[ele] || 0;
    cnt[ele] += 1;
  }
  // 遍历数组索引位置的值，重复项不断推入，最后直接得到结果
  for (let i = 0; i < cnt.length; i++) {
    let ele = cnt[i];
    while (ele) {
      res.push(i);
      ele--;
    }
  }
  return res;
}

console.log(countingSort([0, 2, 9, 8, 6, 1, 3, 4, 5]));
```

#### LeetCode 

* [LeetCode-912](https://leetcode-cn.com/problems/sort-an-array/): 排序数组。这里的场景最适合使用计数排序。
	* 效果百分百。

### 计数排序的时间复杂度

* 从上面的实现可以发现，核心是两次遍历，也就是 `O(2n)` 内可以完成。其中重复数的遍历个人觉得可以忽略不计。
* 因此时间复杂度是 `O(n)`.

### 计数排序的应用场景

* 它的场景比较特殊，**计数排序会用在数据的给定范围比数据体量小很多的地方，而且限定只能是整数。**
* 默认只能支持正整数的排序，如果要支持比如负数的场景，就需要将其在不改变相对大小的情况下先转化为整整数。类似上文 LeetCode 的解法。
* 常见的应用就是上文提到的高考分数排名的场景。

## 基数排序（Radix sort）

### 基数排序的核心思想

* **基数排序核心就是借助稳定排序算法，从最后一位往前一位一位进行排序。因为排序过程是稳定的，所以往前排序也不会改变后面位数的排序结果。**
* 下面是排序过程分解图：

![[基数排序过程.png]]

### 基数排序的时间复杂度

* 根据每一位来排序，我们可以用刚讲过的桶排序或者计数排序，它们的时间复杂度可以做到 `O(n)`。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 `O(k * n)`。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 `O(n)`。

### 基数排序的应用场景

* **基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a  数据的高位比 b 数据大，那剩下的低位就不用比较了。基于这个条件去实现，但是实现过程是从最低位开始向上比较排序。除此之外，每一位的数据范围不能太大，这样可以用线性排序算法来排序，** 否则，基数排序的时间复杂度就无法做到 `O(n)`。
	* 最低位优先(LSD)：从低位向高位排序，可以保证每一位排序结束之后，再进位排序仍然是有序的，而不用关心已排序的低位顺序。
	* 最高位优先(MSD)：从高位向低位排序，需要优先保证高位的顺序，在保证高位顺序不被低位顺序影响的前提条件下，再根据低位比较排序。
* 比如基数排序可以用来排序英文单词。尽管每个单词的字符数不一样，但可以通过补位的方式，在位数不够的单词后面补 0。因为根据[ASCII值](https://zh.wiktionary.org/wiki/US-ASCII)，所有字母都大于“0”，所以补“0”不会影响到原有的大小顺序。这样就可以继续用基数排序了。

### 基数排序的视频演示

* 这个视频较好地演示出基数排序的过程。如果通过上面的文字和图片不足以理解基础排序的原理，可以观看视频来帮助理解。

<iframe src="https://player.bilibili.com/player.html?bvid=BV1D64y1Y7Bd&cid=390107510&page=1&share_source=copy_web" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="520px"></iframe>

## 小结

* 线性时间复杂度的排序算法，有桶排序、计数排序、基数排序。它们对要排序的数据都有比较苛刻的要求，应用不是非常广泛。但是如果数据特征比较符合这些排序算法的要求，使用这些算法之后，会非常高效，线性时间复杂度可以达到 `O(n)` 级别。
* 桶排序和计数排序的思想是非常类似的，都是针对范围不大的数据，将数据划分成不同的桶来实现排序。基数排序要求数据可以划分成高低位，位之间有递进关系。比较两个数，只需要比较高位，高位相同的再比较低位。而且每一位的数据范围不能太大，因为基数排序算法还需要借助桶排序或者计数排序来完成每一位的排序工作。

#ALG
