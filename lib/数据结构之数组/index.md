# 数组

* 数组和链表是最常见的数据结构之一。了解两者就必须要从底层清楚它们的原理和之间的差别。
* 本节先来回顾数组的内容。

## 数组

### 如何实现随机访问

* 首先我们来了解数组的几个特性。
* 第一个，数组就是**线性表**。

#### 线性表

* 除了数组，其他如**栈、队列，链表这些数据结构也是线性表**。
	* 数据通常情况下都是简单的前后关系，只有前后两个方向。

![[线性表.png]]

#### 非线性表

* **非线性表指的是图，二叉树，堆等结构。**
	* 数据之间不只是简单的前后关系。

![[非线性表.png]]

* 第二个特性就是**数组有着连续的内存空间和相同类型的数据。**
* 正是因为这两个特性，数组拥有着其他数据结构所没有的**随机访问**特性。

![[数组的连续存储.png]]

* **计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，会首先通过下面的寻址公式，计算出元素存储的内存地址。**

```shell
a[i]_address = base_address + i * data_type_size
```

* 其中 `data_type_size` 表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是 `int` 类型数据，所以 `data_type_size` 就为 4 个字节。

### 数组的插入和删除

#### 插入

* 默认情况下，在数组中间位置 i 插入数据，会导致 i 之后所有的元素都向后移一位，这个内存的开销是较大的。
* **最好时间复杂度 `O(1)`，最坏时间复杂度 `O(n)`, 平均时间复杂度 `O(n)`, `(1 + 2 + 3 ... + n) / n = O(n)`.**

#### 插入的简单优化

* 如果数组是有序的，则必须按照上面的操作来。
* 如果数组是无序的，无需维持秩序，则可以通过将被插入的值放到数组末尾来解决。这个思想在快速排序中也会用到。

![[数组插入优化.png]]

#### 删除

* 和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 `O(1)`；如果删除开头的数据，则最坏情况时间复杂度为 `O(n)`；平均情况时间复杂度也为 `O(n)`。
* 可以把多次删除合并在一起执行来提高删除的效率。
	* 可以先记录下删除的数据。
	* 每次删除操作不是真正地搬移数据，只是记录数据被删除。
	* 当数组的空间真的不够存储时，再触发执行一次真正的删除操作。
* *这个思想就是 JVM 标记清除垃圾回收算法的核心思想。*

#### 数组的访问越界问题

* 在 C 语言中，所有内存空间都是可以自由访问的。
* 下面这段代码会无限循环打印 `hello world`。

```c
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

* 根据我们前面讲的数组寻址公式，`a[3]` 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 `a[3]=0` 就相当于 i=0，所以就会导致代码无限循环。
* 数组越界在C语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。
* 这种情况下，一般都会出现莫名其妙的逻辑错误，就像我们刚刚举的那个例子，debug 的难度非常的大。而且，很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统，所以写代码的时候一定要警惕数组越界。
* 但并非所有的语言都像 C 语言一样，把数组越界检查的工作丢给程序员来做，像 Java 本身就会做越界检查。

### 从 0 开始的数组

* 那么为何数组会从 0 开始呢？这里存在着两种解释。

#### 节省性能开销

* *从数组存储的内存模型上来看，“下标”最确切的定义应该是**“偏移（offset）”**。* 
* 前面也讲到，如果用a来表示数组的首地址，`a[0]` 就是偏移为0的位置，也就是首地址，`a[k]` 就表示偏移 k 个 `type_size` 的位置，所以计算 `a[k]` 的内存地址只需要用这个公式：

```shell
a[k]_address = base_address + k * type_size
```

* 如果从 1 开始，计算公式就会变成这样：

```shell
a[k]_address = base_address + (k - 1) * type_size
```

* 每一次读取都要多做一次减法的运算，这样的开销无疑是巨大的。从性能上考虑，自然是尽可能的优化效率，减少运算指令。

#### 历史原因

* 当然，也有另一种说法，就是历史原因。
* C 语言的设计者使用 0 开始计算数组的下标，后期的 Java，JavaScript 都借鉴了 C 语言，或者为了减少 C 语言开发者学习 Java 的学习成本，继而沿用了数组从 0 开始计数的习惯。
* 实际上也有很多不是从 0 开始计数的语言，例如 Matlab；甚至还有支持负数下标的的语言，例如 Python.

#Tech #ALG 