# 二分查找(Binary Search)

> 学习曲线：★★★

## 二分查找的核心思想

* 二分查找，又称为**折半查找算法**。
* 生活中就有很多使用二分思想来做的事，比如使用二分思想来猜 0-99 之间的数字。
	* 最多只需要猜七次就可以猜中。

![[二分查找示意.png]]

* 还有例如在有序的订单数组中查找固定金额的订单。
* 为了方便理解，假设只有10个订单，订单金额分别是：8，11，19，23，27，33，45，55，67，98。
	* 以下是示意图：

![[二分查找订单查找.png]]

* **二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过和区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。**

##  二分查找的时间复杂度

* **二分查找的时间复杂度是 `O(logn)`，它是非常高效的查找算法。**

### 计算二分查找的时间复杂度

* 假设数据大小为 n，那么每次查找后数据都会缩小为原来的一半，也就是除以 2。最坏情况下，直到数据为空才会停止。

![[二分查找时间复杂度.png]]
* 可以发现，这时查找过程的数据其实是一个等比数列。
	* 其中 `n/(2^k) = 1` 时，k 的值就是总共缩小的次数。
	* 经过 k 次区间缩小次数我们查找到，时间复杂度就是 `O(k)`.
	* 再通过 `n/(2^k) = 1`, 可以得到结果 `k = log2n`.
* 所以时间复杂度就是 `O(logn)`.

#### O(logn) 算法的高效性

* 这个算法的高效体现在，即便数据量非常之大，我们也只需要很少的次数就可以实现。
* 例如 2 的 32 次方，大约是 42 亿。如果使用二分查找，最多也只需要比较 32 次。
* **O(logn) 的算法有时会比 O(1) 还要快**。因为大 O 表示法通常会省略系数，有时 `O(1)` 其实会表示的是一个较大的常量例如 `O(1000)`, `O(10000)` 等。所以常量级的时间复杂度的算法有时可能还没有 `O(logn)` 的算法执行效率高。

## 二分查找的实现

### 迭代实现

* 迭代实现的主要注意点是左右边界值的更新。

```typescript
/**
 * @description: 二分法的实现，返回的是索引值
 * @param {number[]} arr
 * @param {number} val
 * @return {number}
 */
function binarySearch(arr: number[], val: number): number {
  let low = 0;
  let high = arr.length - 1;

  while (low <= high) {
    // 向下取整
  	const mid = Math.floor(low + (high - low) / 2);
    if (arr[mid] === val) {
      return mid;
    }
    if (arr[mid] < val) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }

  return -1;
}
const list = [1, 2, 3, 4, 5, 6, 7, 8, 9];
console.log(binarySearch(list, 6)); // 5
```

* 我们实现一个生成递增数组的函数，传入较大的数组 1000，然后添加打印日志来观察二分法的执行过程。

```typescript
/**
 * @description: 生成一个递增的有序数组
 * @param {number} count
 * @param {number} initial
 * @return {number[]}
 */
function generateIncrementList(count: number, initial: number = 0): number[] {
  return new Array(count + 1).fill(0).map((_curr: number, index: number) => {
    return initial + index;
  });
}
console.log('查找值的索引是', binarySearch(generateIncrementList(100), 273));
```

* 打印日志的代码.
	* ```console.log(`第 ${idx} 次二分之后的 mid 是 ${mid}, low 是 ${low}, high 是 ${high}`);```

```shell
第 1 次二分之后的 mid 是 500, low 是 0, high 是 1000
=== 查找值比中间值小或相等，更新最大值 1000 -> 499 ===
第 2 次二分之后的 mid 是 249, low 是 0, high 是 499
=== 查找值比中间值大，更新最小值 0 -> 250 ===
第 3 次二分之后的 mid 是 374, low 是 250, high 是 499
=== 查找值比中间值小或相等，更新最大值 499 -> 373 ===
第 4 次二分之后的 mid 是 311, low 是 250, high 是 373
=== 查找值比中间值小或相等，更新最大值 373 -> 310 ===
第 5 次二分之后的 mid 是 280, low 是 250, high 是 310
=== 查找值比中间值小或相等，更新最大值 310 -> 279 ===
第 6 次二分之后的 mid 是 264, low 是 250, high 是 279
=== 查找值比中间值大，更新最小值 250 -> 265 ===
第 7 次二分之后的 mid 是 272, low 是 265, high 是 279
=== 查找值比中间值大，更新最小值 265 -> 273 ===
第 8 次二分之后的 mid 是 276, low 是 273, high 是 279
=== 查找值比中间值小或相等，更新最大值 279 -> 275 ===
第 9 次二分之后的 mid 是 274, low 是 273, high 是 275
=== 查找值比中间值小或相等，更新最大值 275 -> 273 ===
第 10 次二分之后的 mid 是 273, low 是 273, high 是 273
查找值的索引是 273
```

### 递归实现

```typescript
/**
 * @description: 使用递归的方式实现二分查找
 * @param {number[]} arr
 * @param {number} value
 * @param {number} low 设置默认参数
 * @param {number} high 设置默认参数
 * @return {number}
 */
function binarySearchByRecursion(arr: number[], value: number, low = 0, high: number = arr.length - 1): number {
  // 说明未查找到
  if (low > high) return -1;
  const mid: number = ~~(low + (high - low) / 2);
  if (arr[mid] === value) {
    return mid;
  }
  if (arr[mid] <= value) {
    return binarySearchByRecursion(arr, value, mid + 1, high);
  } else {
    return binarySearchByRecursion(arr, value, low, mid - 1);
  }
}

const list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const value = 7;
console.log(binarySearchByRecursion(list, value)); // 6
```

* 类似地，我们创建更大的数组传入，以及加入打印日志，来更好地观察递归的方式的执行过程。
	* 可以发现，虽然有着调用栈的区别，但实际上递归实现的执行顺序和迭代实现的执行顺序是完全一样的。

```shell
==== 第 1 次二分之后的 mid 是 500, low 是 0, high 是 1000
======== 第 2 次二分之后的 mid 是 249, low 是 0, high 是 499
============ 第 3 次二分之后的 mid 是 374, low 是 250, high 是 499
================ 第 4 次二分之后的 mid 是 311, low 是 250, high 是 373
==================== 第 5 次二分之后的 mid 是 280, low 是 250, high 是 310
======================== 第 6 次二分之后的 mid 是 264, low 是 250, high 是 279
============================ 第 7 次二分之后的 mid 是 272, low 是 265, high 是 279
================================ 第 8 次二分之后的 mid 是 276, low 是 273, high 是 279
==================================== 第 9 次二分之后的 mid 是 274, low 是 273, high 是 275
======================================== 第 10 次二分之后的 mid 是 273, low 是 273, high 是 273
```

### 二分查找实现的注意点

#### 循环的条件

* 注意循环的条件是 **`low <= high`** 而不是 ~~`low < high`~~.

#### mid 的取值

* 通常情况下，我们的 mid 取值就是 `(low + high) / 2`.
	* 但可能存在这样的情况，low 和 high 的值都较大，相加后的和会导致溢出。
* 因此更为保险的写法是
	* `const mid = low + (high - low) / 2`。
* 考虑到计算机的位运算比除法运算要更快，所以性能更加优化的写法是
	* **`const mid = low + ((high - low) >> 1)`.**
* 注意：**mid 还需要取整，通常情况下是向下取整。这里也可以用位运算来实现。**
	* **`const mid = ~~(low + ((high - low) >> 1))`.**

#### low 和 high 的更新

* 每当比较完成后，这两个值的更新是递增 1 或者递减 1.
* 因为如果直接相等赋值的话，可能会导致进入死循环。
	* 例如 `low = high = 5` 时，且 arr[5] 不等于 value 这种场景，会导致无法退出循环。
* 正确的写法是：
	* `low = mid + 1`
	* `high = mid - 1`

## 二分查找的应用场景

### 二分查找依赖的是顺序表结构

*  **二分查找依赖的是顺序表结构，或者更加直白的说就是数组。**
*  二分查找不能依赖链表，因为二分查找是需要按照下标来随机访问元素的。
	*  数组的随机访问复杂度是 `O(1)`, 而链表的随机访问复杂度是 `O(n)`.
	*  因此如果数据使用链表存储，二分查找的时间复杂度就会很高，执行效率变得很低。

### 二分查找依赖有序数据

* 二分查找算法应用的数据必须是有序的。如果数据没有序，就需要对其先进行排序操作。
* 之前讲到，排序的时间复杂度最低是 `O(nlogn)`.
	* 针对一组静态数据，没有频繁插入和删除，就可以进行一次排序，多次二分查找。这样排序的成本可以被均摊，二分查找的边际成本就会比较低。
	* 如果数据集合有频繁的插入和删除操作，在使用二分查找的时候，要么可以保证每次插入和删除之后数据仍然是有序的，要么在每次二分查找之前都进行一次排序。针对这种动态数据，无论哪种方法，维护有序的成本都是比较高的。
* **二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。**

### 二分查找不适合数据量太小的场景

* 通常情况下，数据量小的时候直接顺序遍历就足够了。
* 除非，每一次比较会比较耗时。例如比较多个长度超过 300 的字符串。这种场景下，使用二分查找来减少比较次数就会显著提升性能。
	* **数据量小的时候，只有比较操作耗费性能的时候适合使用二分查找。**

### 二分查找不适合数据量太大的场景

* 二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，**要求内存空间连续，** 对内存的要求比较苛刻。
* **二分法需要连续的数组空间，一旦数据量非常大，需要的连续空间也会比较大，申请较大的连续的内存空间可能会导致内存不足。**

## 小结

* 二分查找的核心思想有点类似分治思想，即每次都通过跟区间中的中间元素对比，将待查找的区间缩小为一半，直到找到要查找的元素，或者区间被缩小为 0。但是二分查找的代码实现比较容易写错，需要着重掌握三点：**循环退出条件、mid 的取值，low 和 high 的更新。**
* 二分查找虽然性能比较优秀，但应用场景也比较有限。它的底层必须依赖数组，并且要求数据是有序的。对于较小规模的数据查找，我们直接使用顺序遍历就可以，二分查找的优势并不明显。二分查找更适合处理静态数据，也就是没有频繁的数据插入、删除操作的数据。

## 扩展

### 练习查找平方根

* 使用二分查找实现查找一个数的平方根。
	* 参见 [LeetCode-69](https://leetcode-cn.com/problems/sqrtx/)

```typescript
function mySqrt(x: number): number {
  if (x * x === x) return x;

  let max = x;
  let min = 0; 
  let mid;
  let val; // 用于保存最终的结果值

  while (max >= min) {
    mid = min + ((max - min) >> 1);
    if (mid * mid > x) {
      max = mid - 1;
    } else {
      val = mid;
      min = mid + 1;
    }
  }
  
  return val;
};
```

### 分析在链表中二分查找的时间复杂度

* **链表二分查找的时间复杂度是 `O(nlogn)`.**
* 简单分析就是链表的查询操作复杂度乘以数组原本的二分查找的时间复杂度。`O(n) * O(logn)`
	* 因为相比数组，链表耗费时间更多的就是查找操作，`O(n)` 对比 `O(1)`.
	* **注意这里分析的是单向有序链表。**
	* *这个思路不一定对，但是结果是对的。*

#ALG