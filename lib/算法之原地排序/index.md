# 原地排序

## 简言

* 有些很野生的排序算法，我们极少会用到，例如猴子排序、睡眠排序、面条排序等，这些名字听起来就很陌生。
* 因此下面我们只回顾最经典的一些算法：冒泡排序、插入排序、归并排序、快速排序、计数排序、基数排序、桶排序等。
* 按照时间复杂度把这些经典算法分成三类，也就是分成三个章节来分析。这章分析第一类，也就是原地排序算法。

![[排序一.png]]

* 现在我们带着下面这个问题来进入这一章节。
	* *插入排序和冒泡排序的时间复杂度相同，都是 `O(n²)`,但在实际的软件开发里，为什么都倾向于使用插入排序算法而不是冒泡排序算法呢？*
	* 这里就涉及到算法的分析。

> 学习曲线：★★★

## 如何分析一个“排序算法”

* 分析排序算法，一般可以从三个方面进行，分别是执行效率、内存消耗以及排序算法的稳定性。
* 前面两者，其实就对应时间复杂度和空间复杂度的分析。

### 排序算法的执行效率

#### 1. 最好情况、最坏情况、平均情况时间复杂度

* 在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况和平均情况下的时间复杂度。而且还需要各自复杂度所对应的要排序的原始数据是怎样的。
* 为什么要区分这三种时间复杂度呢？
	* 第一: 部分排序算法会区分，为了好对比，所以我们最好都做一下区分；
	* 第二：对于要排序的数据，有的接近有序，有的完全无序。**有序度**不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。

#### 2. 时间复杂度的系数、常数、低阶

* 在比较不同阶的时间复杂度的算法的时候，因为量级相差较大，我们通常会忽略系数、常数和低阶情况。
* 然而在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。

#### 3. 比较次数和交换（或移动）次数

* 基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。

### 排序算法的内存消耗

* 之前讨论过，算法的内存消耗可以通过空间复杂度来衡量，这也包括排序算法。
* 但针对排序算法的空间复杂度，还有一个概念称之为**原地排序**。
* **原地排序算法特指空间复杂度是 `O(1)` 的排序算法。** 可以理解为有没有借助额外的空间来实现排序。
* 下文介绍的三种排序算法都是原地排序算法。

### 排序算法的稳定性

* 执行效率和内存消耗可以来衡量排序算法的好坏，但这些还不够。针对排序算法还有一个度量指标就是稳定性。
* 可以这样理解：如果待排序的序列中存在值相等的元素，那么经过排序之后，相等元素之间原有的先后顺序不变。
	* **如果排序之后，数据中相等值的顺序不变，这种排序算法就叫作稳定的排序算法；**
	* **如果排序之后，位置发生变化，那对应的排序算法就是不稳定的排序算法。**

#### 理解稳定性的实际应用

* 电商平台中，订单数据根据下单时间和订单金额这两个维度来排序。
	* 使用稳定的排序算法的操作：只要先排序下单时间，再使用稳定的排序算法来排列订单金额，就可以达到效果。
* **稳定的算法保证了金额相等的两个对象在排序之后的前后顺序不变，即经过下单时间排序之后，再次排序可以保证相同金额的订单的顺序不变。**
* 仔细想想，这里的稳定性很简单但却非常实用。从概念上理解很简单，从应用上理解需要多思考。

![[稳定排序应用场景.png]]

## 冒泡排序(Bubble Sort)

* **冒泡排序只会操作相邻的两个数据。**
	* 每次冒泡操作都会对相邻的两个元素进行比较，观察是否满足大小关系的要求。如果不满足就让这两者互换。
	* 一次冒泡（一次遍历）至少会让一个元素移动到它应该在的位置，重复 n 次就完成了 n 个数据的排序工作。
* 下面是排序 `456321` 的冒泡排序过程。

![[冒泡排序.png]]

* 可以看到，经过一次冒泡操作（*从图中左下开始比较，直至右上角*）之后，6 这个元素已经存储在正确的位置上。要想完成所有数据的排序，我们只要进行 6 次这样的冒泡操作就行了。

![[冒泡排序过程.png]]

* 冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。我这里还有另外一个例子，这里面给 6 个元素排序，只需要 4 次冒泡操作就可以了。

![[冒泡排序过程2.png]]

### 冒泡排序算法实现

```typescript
/**
 * @description: 冒泡排序实现
 * @param {number[]} arr
 * @return {number[]}
 */
function bubbleSort(arr: number[]): number[] {
	// 外层的循环表示需要冒泡的次数
  for (let i = 0; i < arr.length; i++) {
	  // 相邻的元素两两比较
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        // 使用数组解构来交换数据
        [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]];
      }
    }
  }
  return arr;
}

console.table(bubbleSort([6, 4, 5, 2, 3, 1]));
```

* 控制台输出：

```shell
┌─────────┬────────┐
│ (index) │ Values │
├─────────┼────────┤
│    0    │   1    │
│    1    │   2    │
│    2    │   3    │
│    3    │   4    │
│    4    │   5    │
│    5    │   6    │
└─────────┴────────┘
```

#### 支持提前退出的冒泡排序实现

* 在某些情况下，数组本身就有序或者通过部分交换已经达到有序的状态，就可以让冒泡排序提前退出，来达到性能优化的效果。

```typescript
/**
 * @description: 支持提前退出的冒泡排序
 * @param {number[]} arr
 * @return {number[]}
 */
function bubbleSort(arr: number[]): number[] {
  for (let i = 0; i < arr.length; i++) {
    let swapped = false; // 当前这一轮比较是否存在交换的情况
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]];
        swapped = true;
      }
    }
    // 如果这一轮循环没有出现交换，说明数组已经有序，可以直接退出，无需继续遍历下去
    if (!swapped) break;
  }

  return arr;
}
```

* 如果我们使用第一种实现对一个数据量较大的数组进行排序，排序后再使用第二种实现进行排序，可以打印出执行时间来确认，第二种排序的时间大大减少。因为省却了大量的比较时间。
* 当然也可以直接执行两次第二种实现，这里为了方便演示，就采用这种方式。
	* 注意，下面的 `randomArr` 数组是借助下文的生成随机数函数来创建的。创建过程这里略过，只需要知道这里数组的量级在 10 万即可。

```typescript
console.time('first bubble');
bubbleSort(randomArr);
console.timeEnd('first bubble');

console.time('second bubble');
bubbleSort(randomArr);
console.timeEnd('second bubble');
```

* 得到如下的结果，显然第二次运行的时间是更高效的，执行时间相差巨大。

```shell
first bubble: 27231.362ms
second bubble: 8.492ms
```

### 冒泡排序三问

#### 1. 冒泡排序是原地排序算法吗

* ***冒泡排序算法只涉及相邻数据的交换操作，只需要常量级的临时空间，所以空间复杂度是  O(1)。是原地排序算法。***

#### 2. 冒泡排序是稳定的排序算法吗

* ***冒泡排序中只有交换才可以改变两个元素的前后顺序。只要我们判断元素大小相等的时候不进行交换操作，那么相同值的数据在排序后不会改变顺序。所以冒泡排序是稳定的排序算法。***

#### 3. 冒泡排序的时间复杂度

* 最好情况下，数据本来就是有序的，那么这时候冒泡排序只需要进行一次遍历操作，最好时间复杂度是 `O(n)`.
* 最坏情况下，数据完全是逆序的，那么需要进行 n 次冒泡操作，所以最坏时间复杂度是 `O(n²)`.

![[冒泡的时间复杂度.png]]

* 最好、最坏情况下的时间复杂度很容易分析，那平均情况下的时间复杂是多少呢？其实平均时间复杂度就是加权平均期望时间复杂度，分析的时候要结合概率论的知识。
* 下面引入两个概念来帮助理解。

##### 有序度

* **有序度是数组中具有有序关系的元素对的个数。** 有序元素可以重复，元素对不会重复。
* 有序元素对用数学表达式表示就是这样。
* 有序元素对：
	* **`a[i] <= a[j]` 同时满足 `i < j`;**

![[有序对.png]]

* 同理，对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度就是 0；
* 对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 **`n * (n - 1) / 2`**，也就是 15。
* 这种完全有序的数组的有序度叫作**满有序度**。

##### 逆序度

* **逆序度的定义和有序度相反（默认从小到大是有序）。**
* 逆序元素对：
	* **`a[i] > a[j]` 同时满足 `i < j`;**

##### 逆序度和有序度的关系
* 关于这几个概念，有一个公式。
	* **逆序度 = 满有序度 - 有序度。**
* **冒泡排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度**，就说明排序已经完成。

![[排序增加有序度.png]]

* 冒泡排序包含两个操作原子，比较和交换。每交换一次，有序度就加 1。不管算法怎如何改进，交换次数总是确定的，即为逆序度，也就是 **`n * (n - 1) / 2 – 初始有序度`**。在这个例子中就是 `15 – 3 = 12`，要进行 12 次交换操作。
* 对于包含 n 个数据的数组进行冒泡排序，平均交换次数可以尝试计算一下。最坏情况是初始有序度为 0，要进行 `n * (n - 1) / 2` 次交换。最好情况下，初始有序度就是满有序度，不需要进行交换。这里假设取中间值来当做初始情况，那么就是 `n * (n - 1) / 4`.
* `n * (n - 1) / 4` 次指的是交换操作，比较操作会比交换操作更多，而这个公式去掉系数就是 `n²`. 而复杂度的上限是 `O(n²)`，所以平均时间复杂度是 `O(n²)`. 
* 这里推导平均情况时间复杂度并不严格但却实用。后面分析快排还是会用到这种分析方式。

## 插入排序（Insertion Sort）

* 有序的数组，如何保证每次添加新的数据之后还是有序的呢？只要遍历数据，找到数据应该插入的位置再将其插入即可。

![[插入排序示意图.png]]

* 这是个动态排序的过程，动态地往有序集合中添加数据，可以通过这种方法保持集合中的数据一直有序。对于一组静态数据，也可以借鉴上面的插入方法来进行排序，这就是插入排序算法。

### 插入排序的核心思想

* 首先把数组中的数据分成**已排序区间**和**未排序区间**。初始已排序区间只有数组的第一个元素。**插入排序的核心思想就是遍历取出未排序区间中的元素，再在已排序区间中适当的位置进行插入，从而保证已排序区间中的元素始终有序。重复这个过程，直到未排序区间的元素为空。** 算法结束。

![[插入排序的过程.png]]

### 插入排序的实现

* 以下是 TS 实现：

```typescript
/**
 * @description: 插入排序，核心是找到当前值需要插入的位置，再直接移动原数组，进行插入
 * @param {number[]} arr
 * @return {number[]}
 */
function insertSort(arr: number[]): number[] {
  const len = arr.length; // 保存数组的长度，因为排序时可能会变化
  if (len <= 1) return arr;

  for (let i = 1; i < len; i++) {
    const ele = arr[i]; // 当前的数字元素先保存，避免覆盖
    let j = i - 1; // 将当前数和前一个数开始比较
    // 以及所有的更前面的数进行比较
    for (; j >= 0; j--) {
      // 从后往前取出拿来对比的数字元素
      const sortedEle = arr[j];
      // 如果前面的数比当前的数更大，说明要把当前数至少插入到那个数之前
      if (sortedEle > ele) {
        arr[j + 1] = sortedEle; // 把当前位置向后移，方便后续的数字插入进来。
        continue;
      } 
      break;
    }
    arr[j + 1] = ele; // 从前往后，插入到最接近的值的后面
  }

  return arr;
}

console.table(insertSort([4, 5, 6, 1, 3, 2]));
```

* 控制台输出：

```shell
┌─────────┬────────┐
│ (index) │ Values │
├─────────┼────────┤
│    0    │   1    │
│    1    │   2    │
│    2    │   3    │
│    3    │   4    │
│    4    │   5    │
│    5    │   6    │
└─────────┴────────┘
```

#### 插入排序的过程

* 我们在上述实现代码中加几行打印代码，打印出每次循环后的变化，来帮助我们理解整个插入排序的过程。
* 插入代码:

```typescript
console.log(`当前存在搬移，arr[${j}]: ${arr[j]} 后移一位，移动至 arr[${j + 1}], j 为 ${j}`);
arr[j + 1] = arr[j];

// 其他逻辑

console.log(`原先的 arr[${i}]: ${ele} 在循环比较后，插入至 arr[${j + 1}], j 为 ${j}`);
arr[j + 1] = ele;
console.log(`--- 第 ${i} 轮插入后, arr 为 [${arr}] ---`);
```

* 执行后打印出日志。

```shell
原先的 arr[1]: 5 在循环比较后，插入至 arr[1], j 为 0
--- 第 1 轮插入后, arr 为 [4,5,6,1,3,2] ---
原先的 arr[2]: 6 在循环比较后，插入至 arr[2], j 为 1
--- 第 2 轮插入后, arr 为 [4,5,6,1,3,2] ---
当前存在搬移，arr[2]: 6 后移一位，移动至 arr[3], j 为 2
当前存在搬移，arr[1]: 5 后移一位，移动至 arr[2], j 为 1
当前存在搬移，arr[0]: 4 后移一位，移动至 arr[1], j 为 0
原先的 arr[3]: 1 在循环比较后，插入至 arr[0], j 为 -1
--- 第 3 轮插入后, arr 为 [1,4,5,6,3,2] ---
当前存在搬移，arr[3]: 6 后移一位，移动至 arr[4], j 为 3
当前存在搬移，arr[2]: 5 后移一位，移动至 arr[3], j 为 2
当前存在搬移，arr[1]: 4 后移一位，移动至 arr[2], j 为 1
原先的 arr[4]: 3 在循环比较后，插入至 arr[1], j 为 0
--- 第 4 轮插入后, arr 为 [1,3,4,5,6,2] ---
当前存在搬移，arr[4]: 6 后移一位，移动至 arr[5], j 为 4
当前存在搬移，arr[3]: 5 后移一位，移动至 arr[4], j 为 3
当前存在搬移，arr[2]: 4 后移一位，移动至 arr[3], j 为 2
当前存在搬移，arr[1]: 3 后移一位，移动至 arr[2], j 为 1
原先的 arr[5]: 2 在循环比较后，插入至 arr[1], j 为 0
--- 第 5 轮插入后, arr 为 [1,2,3,4,5,6] ---
┌─────────┬────────┐
│ (index) │ Values │
├─────────┼────────┤
│    0    │   1    │
│    1    │   2    │
│    2    │   3    │
│    3    │   4    │
│    4    │   5    │
│    5    │   6    │
└─────────┴────────┘
[Done] exited with code=0 in 1.213 seconds
```

### 插入排序三问

#### 1. 插入排序是否是原地排序算法

* ***从实现代码来看，插入排序算法并不需要额外的存储空间，所以空间复杂度是 O(1).*** 是原地排序算法。

#### 2. 插入排序是否是稳定的排序算法

* ***排序过程中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保证原有的顺序依然不变，所以插入排序是稳定的排序算法。***
* 插入的顺序是可控的。

#### 3. 插入排序的时间复杂度是多少

* 最好的情况是原来的数据就是有序的，不需要搬移数据，这种情况下只需要遍历一次数组，最好时间复杂度是 `O(n)`.
* 如果数组是倒序的，相当于每次遍历都要搬移数据，这时最坏时间复杂度是 `O(n²)`.
* 在数组中插入一个数据的平均时间复杂度是 `O(n)`,而对于插入排序来说，每次插入操作都相当于执行一次在数组中插入数据，而具体实现是循环执行 n 次插入操作，平均时间复杂度是 `O(n²)`.

## 选择排序

* 选择排序的算法实现思路类似于插入排序，也会区分**已排序区间**和**未排序区间**。但是**选择排序每次会从未排序区间中找到最小的元素，放在已排序元素的末尾(也就是待排序数组的首位)。**
* **选择排序是把当前数和后面的所有的数进行比较，而插入排序是当前数和前面的所有数进行比较。**

![[选择排序示意图.png]]

### 选择排序的实现

* 以下是TS 实现：

```typescript
/**
 * @description: 选择排序，遍历元素的同时查找未排序的最小值，将其放入已排序数组的最后面
 * @param {number[]} arr
 * @return {number[]}
 */
function selectSort(arr: number[]): number[] {
  if (arr.length <= 1) return arr;

  // 从前往后遍历当前值
  for (let i = 0; i < arr.length - 1; i++) {
    let k = i; // 设定最小值的索引默认为当前值
    // 从当前索引向后遍历，全部遍历完来查找到最小值
    // !每轮遍历从 j 开始的数组就是当前的待排序数组
    for (let j = i + 1; j < arr.length; j++) {
	    // 每找到一个，就重新保存索引；直到找到未排序数组中的最小值
      if (arr[k] > arr[j]) {
        k = j;
      }
    }
    // 使用数组解构来实现交换
    [arr[k], arr[i]] = [arr[i], arr[k]];
  }
  return arr;
}

console.table(selectSort([4, 5, 6, 3, 2, 1]));
```

* 我们可以把比较的过程打印出来，帮助理解。
* 在交换之后打印出数组的内容。添加以下代码：

```typescript
// 里层在循环中打印
console.log(`当前保存的索引是 ${j}，比较的元素是 ${arr[k]} 和 ${arr[j]}`);

// 在外层循环中打印
console.log(`--- 第 ${i} 轮遍历完成 ---`);
console.log(`--- 未排序的数组 [${arr.slice(i)}] 中，最小值为 ${arr[k]} ---`);
console.log(`--- 本轮最终交换的元素是 ${arr[i]} 和 ${arr[k]} ---`);
console.log(`--- 本轮过后数组更新为 [${arr.toLocaleString()}] ---`);
```

* 可以直观的看到每一轮的交换索引和结果。其过程和上面的图片示意内容是一样的。

```shell
当前保存的索引是 3，比较的元素是 4 和 3
当前保存的索引是 4，比较的元素是 3 和 2
当前保存的索引是 5，比较的元素是 2 和 1
--- 第 0 轮遍历完成 ---
--- 未排序的 [4,5,6,3,2,1] 中，最小值为 1 ---
--- 本轮最终交换的元素是 4 和 1 ---
--- 本轮过后数组更新为 [1,5,6,3,2,4] ---
当前保存的索引是 3，比较的元素是 5 和 3
当前保存的索引是 4，比较的元素是 3 和 2
--- 第 1 轮遍历完成 ---
--- 未排序的 [5,6,3,2,4] 中，最小值为 2 ---
--- 本轮最终交换的元素是 5 和 2 ---
--- 本轮过后数组更新为 [1,2,6,3,5,4] ---
当前保存的索引是 3，比较的元素是 6 和 3
--- 第 2 轮遍历完成 ---
--- 未排序的 [6,3,5,4] 中，最小值为 3 ---
--- 本轮最终交换的元素是 6 和 3 ---
--- 本轮过后数组更新为 [1,2,3,6,5,4] ---
当前保存的索引是 4，比较的元素是 6 和 5
当前保存的索引是 5，比较的元素是 5 和 4
--- 第 3 轮遍历完成 ---
--- 未排序的 [6,5,4] 中，最小值为 4 ---
--- 本轮最终交换的元素是 6 和 4 ---
--- 本轮过后数组更新为 [1,2,3,4,5,6] ---
--- 第 4 轮遍历完成 ---
--- 未排序的 [5,6] 中，最小值为 5 ---
--- 本轮最终交换的元素是 5 和 5 ---
--- 本轮过后数组更新为 [1,2,3,4,5,6] ---
┌─────────┬────────┐
│ (index) │ Values │
├─────────┼────────┤
│    0    │   1    │
│    1    │   2    │
│    2    │   3    │
│    3    │   4    │
│    4    │   5    │
│    5    │   6    │
└─────────┴────────┘
```

### 选择排序三问

#### 1. 选择排序是原地排序算法吗

* ***选择排序的空间复杂度是 O(1), 它也没有使用额外空间。所以也是原地排序算法。***

#### 2. 选择排序是稳定的排序算法吗

* ***选择排序查找最小值的过程后，并不会保存相同元素的前后位置。所以是不稳定的排序算法。***
	* 比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素2，与第一个5交换位置，那第一个5和中间的5顺序就变了，就不稳定了。正是因此，相对于冒泡排序和插入排序，选择排序就稍显逊色。

#### 3. 选择排序的时间复杂度

* 选择排序的最好时间复杂度和最坏时间复杂度，以及平均时间复杂度都是 `O(n²)`. 因为不论数组初始值是否有序，它都要进行两轮遍历。这样比较起来，它也比另外两种要逊色一些。

## 冒泡排序和插入排序的比较

* 理论上，这两者排序的平均时间复杂度都是 `O(n²)`. 但是往往插入排序比较受欢迎。下面我们来解答开篇的疑问。
* 从代码实现上看，冒泡排序的数据交换会比插入排序的数据移动要复杂。
* 而且每次比较后，冒泡排序需要三个赋值操作，而插入排序只有一个。

```typescript
// 冒泡排序中数据的交换操作：
if (a[j] > a[j + 1]) { // 交换
   const tmp = a[j];
   a[j] = a[j+1];
   a[j + 1] = tmp;
   flag = true;
}

// 插入排序中数据的移动操作：
if (a[j] > value) {
  a[j + 1] = a[j];  // 数据移动
} else {
  break;
}
```

* 我们可以粗略地把一次赋值当成是单位时间(*`unit_time`*), 分别用冒泡排序和插入排序对逆序度为 k 的数组进行排序。
	* 两者都需要进行 k 次操作，冒泡排序执行 k 次操作，也就是执行了 3k 次赋值；而插入排序执行了 k 次操作，也就是 k 次赋值。这样看来，明显插入排序的性能更好。可以举一个例子来验证。
	* 下面这个方法可以生成由随机数组成的数组，这里我们设定生成一个 10000 个元素组成的数组，分别用两种排序方法进行排序，并查看所需时间。

```typescript
/**
 * @description: 生成数字组成的数组
 * @param {number} len
 * @return {number[]}
 */
function generateArr(len: number): number[] {
  let arr = [];
  let i = 0;
  while (i < len) {
    arr.push(Math.floor(Math.random() * len));
    i++;
  }

  return arr;
}

const randomArr = generateArr(10000);
```

* 下面是两种排序的所需时间。

```typescript
console.time('bubbleSort');
insertSort(randomArr);
console.timeEnd('bubbleSort'); // bubbleSort: 22.06298828125 ms

console.time('insertSort');
bubbleSort(randomArr);
console.timeEnd('insertSort'); // insertSort: 51.6591796875 ms
```

* 在把数组放大到 10000 的长度的场景时，两者的差距就十分明显了。
* 插入排序比冒泡排序的性能好，但也有优化空间。它比较基础，在它之上还有其他排序，例如希尔排序。
* 本次学习不涉及希尔排序，但可以通过扩展自行了解。

## 基础排序小结

![[基础排序小结.png]]

* 实际应用中，通常冒泡排序和选择排序就停留在理论层面，很少会真的用到。我们学习它们是为了启发思维，开拓思路。实际开发中会用到较多的就是插入排序，甚至有些编程语言的排序函数就是使用插入排序实现的。
* 这几种排序的时间复杂度都较高，下面的章节我们来学习时间复杂度为 `O(nlogn)` 的排序算法。

#ALG