# 如何实现一个通用的、高性能的排序函数？

> 学习曲线：★★

## 如何选择合适的排序算法？

* 先回顾下之前学习的各种排序算法的对比情况。

### 各排序的时间复杂度、稳定排序、原地排序情况

![[排序算法汇总比较.png]]

### 各排序的应用场景

* 线性排序的时间复杂度比较低，但是适用场景比较特殊，不能作为通用性的排序函数，首先排除。
* 小规模的数据排序可以使用时间复杂度是 `O(n²)` 的算法；
* 大规模的数据排序可以使用时间复杂度是 `O(nlogn)` 的算法；
* 综合比较，**通常会选择使用 `O(nlogn)` 复杂度的排序算法来实现函数。**
* 符合复杂度 `O(nlogn)` 的算法中目前已学习的就是**快排**和**归并排序**。
	* 我们知道归并排序有空间复杂度高的缺点，所以综合比较后，我们选择**快排**。
* 那么剩下的问题就是如何优化快排，来避免它变成 `O(n²)` 的时间复杂度。

### 如何优化快速排序

* **快速排序的核心优化在于找到尽可能把数组平分的分区点。**
* 下面是两个比较常用也比较基础的分区算法，来取得较为合理的分区点。

#### 三数取中法

* **从数组的首位，中位和末尾各取一个数字，比较大小得到处于中间位置的数据作为分区点。**
* 这样的分区点就是比较分散的分区点，效果肯定比单纯取一个数更好。
* 但也存在可能数据量较大的情况，这时可以尝试 **“五数取中”**，甚至 **“十数取中”** 的方式。

#### 随机取数法

* **随机法就是每次从要排序的区间中随机取出一个数来作为分区点。**
* 这个方法不能保证每次都取得一个比较平衡的分区点；但是从概率论的角度来看，也不会出现分区点取得较差的场景。
* 平均下来，时间复杂度不太会退化到 `O(n²)` 的情况。这样的分区点也是比较合适的。

### 快排实现的注意点

* 通常快排是用**递归**实现的，因此要**警惕堆栈溢出**。
* 可以通过两个方式来避免：
	* 限制递归深度；一旦超过预先设置的阈值，就停止递归。
	* 在堆上模拟实现函数调用栈，手动模拟递归压栈，出栈的过程，这样就没有了系统栈大小的限制。

## 举例分析排序函数

### 分析 C 语言中的 qsort 方法

* 观察 `qsort` 的源码可以发现，`qsort` 不仅仅是用一种快排算法来实现的。
	* **在数据比较小的时候，`qsort` 方法会使用归并排序来实现，核心是空间换时间的思路，** 而且在数据量比较小的时候，内存空间占用也并不会很大。
	* **当数据量较大的时候，`qsort` 会使用快速排序算法来进行排序。**
		* 而 `qsort` 查找分区点的算法就是三数取中法，其实并没有特别复杂。
		* 避免递归堆栈溢出的问题，`qsort` 通过手动实现堆上的栈，模拟递归来完成的。
	* 而且在 `qsort` 的快速排序中，**如果区间的个数小于 4 的时候，它又会使用插入排序而不是快速排序来实现。**
	 	* 因为在小规模数据的时候，`O(n²)` 时间复杂度算法所耗费的时间，不一定比 `O(nlogn)` 的时间更长。
* 下面我们进一步分析。

#### 时间复杂度分析

* **时间复杂度实际上表示的是一种增长趋势。**
	* 时间复杂度越高，趋势会更陡峭，意味着通常当数 n 越大时，耗费的时间越长。
* 但是之前分析复杂度的时候，也有提到我们会**省略低阶**，**系数**和**常数**这些变量。
* 换言之，`O(nlogn)` 在没有省略低阶，系数和常数之前可能是 `O(knlogn + c)`, 而且 k 和 c 可能还是一个较大的数。
* 假设 `k=1000`，`c=200`，当我们对小规模数据（比如 `n=100`）排序时，`n²` 的值实际上比 `knlogn+c` 还要小。

```typescript
knlogn+c = 1000 * 100 * log100 + 200 远大于10000
n^2 = 100*100 = 10000
```

* 所以，**对于小规模数据的排序，`O(n²)` 的排序算法不一定比 `O(nlogn)` 排序算法执行时间长。**
	* 对于**小数据量的排序**，就会选择使用比较简单，也不需要递归的**插入排序算法**。
* 除此之外，`qsort` 也使用了哨兵技巧来提高执行效率。因为在底层基础函数的实现中，性能的优化要做到极致，然后为上层提供更好的服务。

## 小结

* 通过分析一个工业级的、语言级别的排序算法实现，我们相对更深入的了解了算法的实践应用。

### 扩展

* 可以试着查看 JS 中数组 sort 函数的具体实现，来更深入地理解算法以及学习实践中的优化技巧。

#ALG 