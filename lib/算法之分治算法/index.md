# 分治算法

## 简言

* [MapReduce](https://www.wikiwand.com/zh-hans/MapReduce) 的本质就是分治算法思想。

> 学习曲线：★★★★

## 如何理解分治算法

* **分治算法(`divide and conquer`)核心就是分而治之，把原问题分解成 n 个规模较小，并且结果与原问题相似的子问题，递归地解决这些子问题，再合并其结果，就得到原问题的解。**
* 这个定义看起来会和递归有些相似，这两者的区别，在之前也有提到：**分治算法是一种处理问题的思想，递归是一种编程技巧。** 而分治算法一般都比较适合使用递归来实现。
* 分治算法的递归实现中，每一层递归都会涉及三个**操作**：
	* **分解：把原问题分解成一系列子问题；**
	* **解决：递归地求解各个子问题，如果子问题足够小，则直接求解；**
	* **合并：把子问题的结果合并成原问题。**

### 分治算法解决的问题

* 而分治算法能解决的问题，一般需要符合下面的几个**条件**：
	* **原问题和分解成的小问题具有相同的模式；**
	* **原问题分解成的子问题可以独立求解，子问题之间没有相关性；这点是分治算法和动态规划的主要区别，** 动态规划的章节会继续对比；
	* **具有分解终止条件，也就是当问题足够小时，可以直接求解；**
	* **可以把子问题合并成原问题，而且这个合并操作的复杂度不能太高，否则就不能起到减小算法总体复杂度的效果。**

## 分治算法应用举例分析

* 我们通过一个具体案例来加深对分治算法的理解。在前面的章节中，我们有提到**一组数据的有序度、逆序度**的概念。
	* **有序度表示一组数据的有序程度，逆序度表示一组数据的无序程度。**
* 假设有 n 个数字，我们期望数据从小到大排列，那么完全有序的数据的有序度就是 `n(n-1)/2`, 逆序度等于 0；相反，倒序排列的数据的有序度就是 0，逆序度是 `n(n-1)/2`. 除了这两种极端情况，我们通过计算有序对或者逆序对的个数，来表示数据的有序度或者逆序度。

![[逆序对个数.png]]

* 如何编程求出一组数据的有序对个数或者逆序对个数？因为有序对个数和逆序对个数的求解方式是类似的，所以可以只用考虑其中一种逆序对个数的求解方法。

### 暴力求解逆序度(冒泡排序)

* 可以使用暴力匹配的方式，匹配所有的情况，拿每个数字和它后面的数字比较，观察有几个比当前数字更小，这个比较思路有些类似于冒泡排序。通过这样的方式，把比当前数字更小的数字记作 k ，遍历所有数字之后，累加每个数字对应的 k 的和，得到最终的结果就是逆序对的个数。这个过程类似于冒泡，实际上冒泡排序也确实可以做到，因为冒泡排序本质就是两两比较的。

```typescript
// 冒泡排序是两两比较的，所以比较的时候就可以找到所有逆序对
// 但是冒泡排序的时间复杂度较高
function bubbleSort(arr: number[]): number[] {
  let reversePairsCount = 0;
  const len = arr.length;
  for (let i = 0; i < len; i++) {
    for (let j = 0; j < len - i - 1; j++) {
      const eleI = arr[j];
      const eleJ = arr[j+1];
      if (eleI > eleJ) {
        reversePairsCount++;
        [arr[j+1], arr[j]] = [arr[j], arr[j + 1]];
      }
    }
  }
  console.log('reversePairsCount is', reversePairsCount);
  return arr;
}
console.log(bubbleSort([7, 4, 5, 3, 2, 1, 6])); // 15
console.log(bubbleSort([4, 5, 3, 2, 1, 6])); // 9
```

* 但是暴力匹配的方式也就是这里所用的冒泡排序，它的时间复杂度是 `O(n²)`.  对于已比较的结果，冒泡排序并不会保存，导致不够高效。有没有更高效的方式呢？

### 分治思想求解逆序度(归并排序)

* 应用分治算法的思路求数组 A 的逆序对个数。首先把数字分割成前后两半 A1 和 A2，分别计算 A1 和 A2 的逆序对个数 K1 和 K2，再计算 A1 和 A2 之间的逆序对个数 K3. 那么数组 A 的逆序对个数就等于 K1 + K2 + K3。
	* **而且需要注意的是，子问题合并的代价并不能太大，否则就无法起到降低时间复杂度的效果。**
* 我们可以借助归并排序算法来计算子问题 A1 和 A2 的逆序对个数。
	* 归并排序中的一个关键操作就是把两个有序的小数组合并成一个有序的数组。在这个合并的过程中，我们可以计算出这两个小数组的逆序对个数，每次合并操作，我们都计算逆序对个数，把这些计算出来的逆序对个数求和，就得到当前数组的总的逆序对个数。

![[归并排序求解逆序对个数过程.png]]

* **在每次把两个已排序的数组中的数字进行合并时的比较排序，其实就可以得到每个数字所对应的逆序对。**
* 通过代码来更好地理解整体的求解过程。

```java
private int num = 0; // 全局变量或者成员变量

public int count(int[] a, int n) {
  num = 0;
  mergeSortCounting(a, 0, n-1);
  return num;
}

private void mergeSortCounting(int[] a, int p, int r) {
  if (p >= r) return;
  int q = (p+r)/2;
  mergeSortCounting(a, p, q);
  mergeSortCounting(a, q+1, r);
  merge(a, p, q, r);
}

private void merge(int[] a, int p, int q, int r) {
  int i = p, j = q+1, k = 0;
  int[] tmp = new int[r-p+1];
  while (i<=q && j<=r) {
    if (a[i] <= a[j]) {
      tmp[k++] = a[i++];
    } else {
      num += (q-i+1); // 统计p-q之间，比a[j]大的元素个数
      tmp[k++] = a[j++];
    }
  }
  while (i <= q) { // 处理剩下的
    tmp[k++] = a[i++];
  }
  while (j <= r) { // 处理剩下的
    tmp[k++] = a[j++];
  }
  for (i = 0; i <= r-p; ++i) { // 从tmp拷贝回a
    a[p+i] = tmp[i];
  }
}
```

### 分治算法中使用归并排序求解逆序度(TS)

* TS 版本的实现。

```typescript
/**
 * @description: 归并排序求出逆序对
 * @param {number} arr
 * @param {number} start
 * @param {number} end
 * @return {number}
 */
function getReversePairs(arr: number[], start = 0, end = arr.length - 1): number {
  if (start >= end) return 0;

  const middle = Math.floor((start + end) / 2);
  let res = getReversePairs(arr, start, middle) + getReversePairs(arr, middle + 1, end);
  let i = start, j = middle + 1, k = 0;
  const len = end - start + 1; // 子数组长度
  let tmp: number[] = new Array(len); // 当前分区的子数组
  
  while (i <= middle && j <= end) {
    if (arr[i] <= arr[j]) {
      tmp[k++] = arr[i++];
    } else {
      // !其实是初始的右侧的位置索引 middle + 1，减去左侧较大数的索引，得到左侧比右侧大的数字的数量
      res += middle - i + 1;
      tmp[k++] = arr[j++];
    }
  }

  // 左边索引未到中间值，说明左边数组有剩余，将剩余的左边数组放入
  while (i <= middle) {
    tmp[k++] = arr[i++];
  }

  // 右边索引未到末位值，说明右边数组有剩余，将剩余的右边数组放入
  while (j <= end) {
    tmp[k++] = arr[j++];
  }

  // 所有数字放入原数组
  // !因为本次子数组的排序是从 start 位置开始的，下方也需要加上 start 保证子数组的值和原数组的一致
  for (let i = 0; i < len; i++) {
    // 把已排序的子数组的值按序赋值回原数组
    arr[start + i] = tmp[i];
  }

  return res;
}

console.log(getReversePairs([7, 4, 5, 3, 2, 1, 6])); // 15
console.log(getReversePairs([4, 5, 3, 2, 1, 6])); // 9
console.log(getReversePairs([4, 7, 5, 1, 6])); // 5
```

* 对应 [LeetCode](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/) 中的题目，难度竟然是困难。
* 可以参考之前的[[Tech/技术笔记/《算法与数据结构》学习笔记/算法之分治思想基础排序/index#归并排序的核心思想|归并排序]]。

### 分治算法的其他经典问题

* 二维平面上有 n 个点，如何快速计算出两个距离最近的点对？
* 有两个 `n * n` 的矩阵 A，B，如何快速求解两个矩阵的乘积 `C = A * B`?

### 分治思想在海量数据处理中的应用

* 分治算法的应用是十分广泛的，并不仅限于指导编程和算法设计，它还经常用于海量数据处理的场景中。
* 前面章节的数据结构和算法，大多都是基于内存存储和单机处理，但是如果要处理的数据量非常大，无法一次性放入内存中，数据结构和算法就会无法工作。
* 例如，给 10GB 的订单文件按照金额排序这样的需求，表面看似简单，但是因为数据量巨大，而机器内存可能只有 2、3GB，无法一次性加载到内存，也就无法单纯通过快排、归并等基础排序算法来解决。
* 要解决这类数据量巨大的情况，就可以使用分治的思想。我们把海量的数据集合根据某种方法划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后再把小的数据集合合并成大数据集合。
	* 实际上，使用这种分治的处理思想，不仅能够克服内存的限制，还可以利用多线程或者多机处理，加快处理的速度。
	* 例如刚才的例子，我们可以先扫描一遍订单，根据订单的金额把 10GB 的文件划分为几个金额区间。比如 100 以内的放到一个小文件，101 到 200 的金额放到另一个文件，依次类推。这样每个小文件都可以加载到内存并进行排序，最后再把这些小文件合并，就是有序的 10GB 订单数据。
		* *个人理解，扫描一遍订单就是遍历一遍订单，内存不够进行全量排序，但是是足够做分批遍历操作的，然后此时并不进行排序而是单纯根据数据的大小放入对应的区间，而这些区间是预先设置好的，可以理解为简单粗暴的划定或者根据历史数据经验划定。*
	* 现在常见的使用集群并行处理，也可以理解为是分治思想的一种应用，并且集群处理正在逐渐成为一种趋势。

#### MapReduce

* MapReduce 只是一个任务调度器，底层依赖 GFS 来存储数据，依赖 Borg 管理机器。它从 GFS 中取数据，交给 Borg 中的机器执行，并且时刻监控机器执行的进度，一旦出现机器宕机、进度卡壳等，就重新从 Borg 中调度一台机器执行。
* MapReduce 在 Google 内部的应用非常广泛。不仅可以用来处理数据与数据之间存在关系的任务，例如统计文件中单词出现的频率。它还可以用来处理数据与数据之间没有关系的任务，例如对网页分析，分词等，每个网页都可以独立地进行分析和分词，而这些网页之间是没有任何联系的。
	* MapReduce 提供的就是十分高可用、高性能、高容错的并行计算框架，并行处理几十亿甚至上百亿的网页。

## 小结

* 分治算法其实就是分而治之，把原问题划分成 n 个规模较小但结构和原问题相似的子问题，递归地解决这些子问题，然后再合并结果，最终得到原问题的解。
* 这篇章节里主要聚焦两个分治算法的应用场景，一个是用于指导编码，降低问题求解的时间复杂度；另一个是解决海量数据处理的问题。比如 [MapReduce](https://www.wikiwand.com/zh-hans/MapReduce) 本质上就是应用了分治思想。

## 扩展

* *回顾之前的数据结构，算法，解决思路，还有举的例子，哪些使用了分治算法思想呢？*
* *生活和工作中中有哪些地方用到分治算法呢？可以回忆并举例。*

#ALG 