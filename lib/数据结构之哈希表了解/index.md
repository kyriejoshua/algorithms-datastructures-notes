# 哈希表（Hash Table）

> 学习曲线：★★★☆

* 哈希表又称为**散列表**。

## 散列思想

* **散列表使用的是数组支持下标随机访问数据的特性；本质上散列表其实是数组的一种扩展。**
	* 散列表用的就是数组支持下标随机访问数据的时候，时间复杂度是 `O(1)` 的特性。
* 通过散列函数，把元素的键值映射为下标，然后将数据存储在下标的位置；按照键值查询元素的时候，同样使用散列函数把键值转为下标，在数组的对应位置读取数据。

![[散列表简单示意.png]]

* 上图的这个散列表，就是把最后两位作为索引，然后转化为数据：

```typescript
const u = undefined; // 为方便演示，使用 u 作为空数据的占位符。
const arr: Array<undefined|number> = [u, u, 060402, u, u, u, 050306, u, u, 030909, u, u, u, u, u, u, u, 030817];
```

## 散列函数（哈希函数或称 Hash 函数）

* `hash(key)`
* 其中 `key` 表示元素的键值，`hash(key)` 的值表示经过散列函数计算得到的散列值。
* 在运动会的运动员编号中，把最后两位当成数组下标的场景，简化成伪代码如下：

```java
int hash(key) {
	// 获取后两位字符
	string lastTwoChars = key.substr(length - 2, length);
	// 将后两位字符转为整数
	int hashValue = convert lastTwoChars to int-type;
	return hashValue;
}
```

* 对应到上面图中的案例，转成具体的 ts 代码:

```typescript
function getHashKey(key: string): number {
	const lastTwoChars: string = String(key).slice(String(key).length - 2);
	
	return Number(lastTwoChars);
}

console.log(getHashKey('030817')); // 17
console.log(getHashKey('060402')); // 2
```

### 散列函数的三个核心要求

#### 散列函数计算得到的散列值是非负整数

* 散列值会成为数组的索引，所以必须是非负整数。

#### 相同 key 值得到的散列值相同

* **如果 `key1 = key2`, 那么 `hash(key1) = hash(key2)`.**
* 也就是如果输入相等的 key，也会有着相等的输出。类似纯函数的概念。

#### 不同 key 值得到的散列值不同

* **如果 `key1 != key2`, 那么 `hash(key1) != hash(key2)`.**
	* 这一条是最重要的部分。
	* 理论上看这个要求很合理且简单，但实际上非常难以做到。要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎不可能。即使在非常有名的哈希算法里，也无法避免。
* 当不同的 key 输入，却得到相同的哈希值时，就说明出现了**散列冲突**（*哈希冲突*）。
* 下面介绍几种比较常见的冲突解决方法。

### 散列冲突

* 通常使用的散列冲突解决方法有两类：**开放寻址法（open adressing）和链表法(chaining)。**

#### 1. 开放寻址法

* 开发寻址法的核心思想是，如果出现了散列冲突，就重新探寻一个新的空闲位置。
* 先介绍一个比较简单的方法，线性探测。

##### 线性探测（Linear Probing）

* **当往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用，就从当前位置开始，依次往后查找，直到找到空闲位置为止。**
* 下面的示意图，**黄色色块表示空闲位置，橙色色块表示已经存储数据**。

![[线性探测示意.png]]
* 从图中可以看出，散列表的大小为 10，在元素 x 插入散列表之前，已经 6 个元素插入到散列表中。x 经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。于是我们就顺序地往后一个一个找，查看是否有空闲的位置，遍历到尾部都没有找到空闲的位置，于是我们再从表头开始找，直到找到空闲位置 2，于是将其插入到这个位置。
* **在散列表中查找元素的过程类似插入过程**。通过散列函数计算得到要查找的元素的键值对应的散列值，再比较数组中下标为散列值的元素和要查找的元素。如果相等，这就是要查找的元素；否则就顺序向后依次查找。**如果遍历到数组中的空闲位置还没有找到**，就说明当前元素并不在散列表中。

![[线性探测复杂示意.png]]

* 散列表和数组一样，也支持**插入、查找还有删除操作**。
* 对于使用线性探测法解决冲突的散列表，删除操作比较特别，不能直接把要删除的元素设置为空。
* 因为通过线性探测方法查找到空闲位置，就可以认定散列表中不存在这个数据；但如果这个数据是后来删除的，就会导致原来的查找算法失效；
	* 可以理解为这个时候 `hash(key1) === hash(key2)`，但 key1 和 key2 是不一定相等的，这就违反了上述三大核心要求之一。
* 解决方案也比较简单，只需要将删除的元素，标记为 `deleted` 即可。俗称打一个标。
	* 线性探测查找的时候，遇到标记为 `deleted` 的空间，直接跳过向后继续探测即可。

![[线性探测删除示意图.png]]

* 线性探测存在的问题是，当散列表中插入的数据越来越多时，散列冲突发生的可能性就越来越大，毕竟空间有限，空闲位置就会越来越少，线性探测的时间也会越来越久。
* 极端情况下，可能要探测整个散列表，也就是最坏情况下的时间复杂度是 `O(n)`.
* 同理，删除和查找也会遇到这个问题。
* 对于开发寻址类的冲突解决方法，还有两种比较经典的探测方法：**二次探测和双重散列**.

##### 二次探测 （Quadratic probing）

* 二次探测是和线性探测非常相似，线性探测每次的步长是 1. 那么每次探测的下标序列就是 `hash(key)`, `hash(key) + 1`, `hash(key) + 2`.
* 而**二次探测就是把每次探测的步长变为了“二次方”。** 每次探测的步长为：`hash(key) + 0^2`, `hash(key) + 1^2`, `hash(key) + 2^2`, `hash(key) + 3^2`.

##### 双重散列（Double hashing）

* **双重散列就是不仅仅使用一个散列函数，而是使用一组散列函数 `hash1(key)`, `hash2(key)`, `hash3(key)` 等等。实际中先使用第一个散列函数，如果计算得到的存储位置已经被占用，再使用第二个散列函数，依次类推，直到找到空闲的存储位置。**

##### 开发寻址法解决冲突的重要因素

* 不管使用上述哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。
* 为了尽可能保证散列表的操作效率，一般情况下，会尽可能保证散列表中有一定比例的空闲槽位。
* 我们使用**装载因子（load factor）** 来表示空位的多少。
* 装载因子的计算公式：

```shell
散列表的装载因子 = 填入表中的元素个数 / 散列表的长度
```

* 装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。

#### 2. 链表法

* **链表法是更加常用的散列冲突解决办法**。它比开放寻址法简单很多。
* 在下面的图中，每个桶（bucket）或槽（slot）都会对应一条链表，所有散列值相同的元素都会放到相同槽位对应的链表中。

![[散列冲突之链表法.png]]

* **插入的时候，只需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可。**
	* 因此，**插入的时间复杂度是 `O(1)`.**
* 查找和删除一个元素时，同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。
* **查找和删除，都需要精确找到槽中对应的值。这两种操作的时间复杂度和链表的长度成正比。假设链表的长度为 k, 时间复杂度就是 `O(k)`.**
* 对于散列比较均匀的散列函数来说，理论上，`k = n / m`, 其中，n 是散列中数据的个数，m 表示散列表中“槽”的个数。

## 散列表的实现

* 这是 TS 实现基础的[散列表](https://github.com/kyriejoshua/javascript-datastructure/tree/main/src/HashTable)，解决冲突使用的方案是线性探测。
* 后续需要实现链表法解决冲突的散列表。详见下一章节。

## 散列表的应用

* 现在计算机应用中的 Word 文档里的单词拼写检查，就使用散列表实现。存储 20 万个英文单词（平均每个单词10个字母也就是10个字节）的内存空间也是 2MB，放大十倍也只有 20MB，在现代计算机中是比较小的数字，完全可以放在内存中，随时取用。
* 因此现代计算机中，可以使用散列表来存储整个英文单词词典，当用户输入英文单词时，使用这个单词去散列表中查找。如果查到说明拼写正确，如果没有查到，说明拼写可能有误，给予相应的提示。
* 借助散列表这种数据结构，可以轻松实现快速判断是否存在拼写错误。

## 小结

* 这一节主要关注的是散列表的由来、散列函数，以及散列冲突的解决方法。
* 散列表来自于数组，借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性来提高操作的效率。
* 散列表的两个核心问题是散列函数设计和散列冲突解决。
* 散列冲突有两种常用的解决方法，开放寻址法和链表法。
* 散列函数设计的好坏决定了散列冲突的概率，也就决定了散列表的性能。

## 扩展

1. 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？
	* 保存键值对 `{ [url]: logCount }` 在数组中；
	* 再根据访问次数 `logCount` 进行排序。

2. 有两个字符串数组，每个数组大约有十万条字符串，如何快速找出两个数组中的相同的字符串？
	* 类似题：[LeetCode-599](https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/)
	* 下面是 LeetCode 解法，核心思路是一样的：

```typescript
/**
 * @description: 哈希表的思路
 * 时间复杂度 O(n + m)
 * 空间复杂度 O(n)
 * @param {string[]} list1
 * @param {string[]} list2
 * @return {string[]}
 */
function findRestaurant(list1: string[], list2: string[]): string[] {
  let restMap = new Map(); // 保存餐厅的键值对
  let minRest = new Map(); // 保存最小索引的餐厅

  // 保存一份第一餐厅的索引
  for (let i = 0; i < list1.length; i++) {
    restMap.set(list1[i], i);
  }

  for (let i = 0; i < list2.length; i++) {
    // 假如有相同的，进入判断
    if (restMap.has(list2[i])) {
      const restIndex = restMap.get(list2[i]);

      if (minRest.size) {
        const curMinRest = minRest.values().next().value;
        // 如果当前索引和小于之前保存的，就直接保存这个新的餐厅及索引
        if (curMinRest > (restIndex + i)) {
          minRest.clear();
          minRest.set(list2[i], restIndex + i);
        // 如果和之前的相等，就一并保存
        } else if (curMinRest === (restIndex + i)) {
          minRest.set(list2[i], restIndex + i);
        }
      } else {
        minRest.set(list2[i], restIndex + i);
      }
    }
  }

  // 返回所有键，也就是已保存的所有餐厅
  return [...minRest.keys()];
};
```

#ADT #ALG 