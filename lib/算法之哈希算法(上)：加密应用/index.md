# 哈希算法的应用

## 简言

* 本节主要讨论在实际的开发中，如何使用哈希算法解决问题。

> 学习曲线：★★☆

## 什么是哈希算法

* 哈希算法的定义：**将任意长度的二进制值串映射为固定长度的二进制值串，其中的映射规则就是哈希算法；通过原始数据映射之后得到的二进制值串就是哈希值。**
* 一个优秀的哈希算法至少需要满足以下几点要求：
	* **从哈希值不能反向推导出原始数据（因此哈希算法也叫单向哈希算法）；**
	* **对输入数据非常敏感，即使原始数据只修改了一个 Bit，所得到的哈希值也会大不相同；**
	* **散列冲突的概率非常小，对于不同的原始数据，哈希值相同的概率非常小；**
	* **哈希算法的执行效率需要尽可能高效，针对较长的文本，也能快速计算出哈希值。**
* 下面以 MD5 哈希算法来具体说明。
* 分别对`“今天我来讲哈希算法”`和`“jiajia”`这两个文本，计算 MD5 哈希值，得到两串看起来毫无规律的字符串（*MD5 的哈希值是 128 位的 Bit 长度，这里为方便表示，把它们转化成 16 进制编码*）。
	* 可以发现，无论字符串多长，通过哈希算法计算得到的值的长度都是相同的，而且看起来就是一段随机数。

```java
// 两段哈希值
MD5("今天我来讲哈希算法") = bb4767201ad42c74e650c1b6c03d78fa
MD5("jiajia") = cd611a31ea969b908932d44d126d195b
```

* 再来看两个非常相似的文本，`“我今天讲哈希算法！”`和`“我今天讲哈希算法”`。这两个文本尽管只有一个感叹号的区别，通过 MD5 哈希算法分别计算得到的哈希值也全然不相同。

```java
// 完全不同
MD5("我今天讲哈希算法！") = 425f0d5a917188d2c3c3dc85b5e4f2cb
MD5("我今天讲哈希算法") = a1fb91ac128e6aa37fe42c663971ac3d
```

* 就结果而言，可以看出是非常难以反向推导出原始数据的，这也是哈希算法的一大重要特性。
* 下面来介绍哈希算法在实践中的应用场景。最常见的几个分别是
	* **安全加密；**
	* **唯一标识；**
	* **数据校验；**
	* **散列函数；**
	* **负载均衡；**
	* **数据分片；**
	* **分布式存储。**
* 这节我们先关注前面四个。

## 哈希算法的应用场景

### 场景一：安全加密

* 最常想到的哈希算法的应用就是安全加密。而最常用的哈希算法就是 **MD5(MD5 Message-Digest Algorithm，MD5消息摘要算法) 和 SHA(Secure Hash Algorithm，安全散列算法).**
	* 其他当然也有比较常见的加密算法，例如 *DES(Data Encryption Standard，数据加密标准) 和 AES(Advanced Encryption Standard，高级加密标准).*
* 在加密的场景中，哈希算法的这两点要求尤其重要，
	* **1. 根据哈希值反向推导出原始数据非常困难；**
	* **2. 散列冲突的概率要控制的极小。**
* 第一点比较好理解，加密的目的就是防止原始数据泄露，所以要很难通过哈希值反向推导原始数据。这是基本的要求。
* 第二点，散列冲突的概率要控制的很小，因为**事实上没有办法做到完全避免冲突**。
	* 这是基于数学中一个非常基础的理论，**鸽巢原理（又叫抽屉原理）**。原理内容是，如果有 10 个鸽巢，且有 11 只鸽子，那么肯定有 1 个鸽巢中的鸽子多于 1 个。也就是说至少有 2 只鸽子会在 1 个鸽巢内。
	* 在哈希算法中，产生的哈希值的长度时固定且有限的。比如 MD5 的例子，哈希值是固定的 128 位二进制串，表示的数据最多是 `2^128`，而现实中我们要哈希的数据是无穷的。
		* 基于鸽巢原理，如果对 `2^128+1` 个数据求哈希值，那么必然至少会有两个数据产生的哈希值是一样的。
		* 而一般情况下，哈希值越长的哈希算法，散列冲突的概率越低。

```typescript
2^128=340282366920938463463374607431768211456
```

* 下面是更直观的感受。图片里的这两段字符串，使用 MD5 哈希算法加密之后，得到的哈希值是相同的。

![[哈希值相同之一.png]]
![[哈希值相同之二.png]]

* 而即便哈希算法存在散列冲突的情况，但是因为哈希值的范围很大，冲突的概率极低，所以相对来说仍然是很难破解的。例如 MD5，有 2^128 个不同的哈希值，这个数据已经是一个天文数字，所以散列冲突的概率小于 `1/2^128`，也是非常之低。
* 通过穷举的方法来找到和这个 MD5 值相同的另一个数据，所耗费的时间也是天文数字级别的。
* 因此在有限的资源和时间下，哈希算法仍然是很难破解的。
* 在现实中，没有绝对安全的加密。越复杂，越难破解的加密算法，需要的计算时间也越长。比如 `SHA-256 `比 `SHA-1` 更复杂也更安全，但计算时间也更长。
* **实际应用中，需要权衡破解难度和计算时间，来决定使用哪一种加密算法。**

### 场景二：唯一标识

* **在海量的图片中查询一张图片，可以通过给图片添加唯一标识的方式，来达到快速查询的效果。**
* **唯一标识可以理解为信息摘要，** 从图片的二进制码串的开头和中间和末尾各取 100 个字节，拼接后再通过哈希算法（例如 MD5）得到一个哈希字符串，把它当成是图片的唯一标识。
	* 通过这个唯一标识来判定图片是否存在于图片中，可以提高很多效率。
* 如果需要继续提升查询效率，*可以把每个图片的唯一标识，和图片文件在图库中的存储路径一并存在散列表中。*
	* 当要查询某一图片时，先通过哈希算法得到这张图片的唯一标识，再在散列表中查找是否存在这一标识。
	* 如果不存在，说明图片不在图库中；
	* 如果存在，再通过散列表中存储的文件路径，获取到这个已经存在的图片和插入的图片做全量的比对，确认是否完全一样。
		* 如果一样，	说明已经存在；
		* 如果不一样，说明两张图片尽管唯一标识相同，但并不是相同的图片。（*例如在某一应用中下载图片并改变存储路径，然后回到应用又下载一次原图，这时两张图片内容相同，但存储路径不同*）

### 场景三：数据校验

* 例如电驴 BT 下载软件，其原理是基于 P2P 协议的。可以从多个机器上并行下载一个 2GB 的电影，它会分割成很多文件块，（例如 100 块，每块大小约 20MB）。等所有文件块下载完毕，再组装成完整的电影文件。
* 由于网络传输的不安全性，下载的文件块可能会被宿主机器恶意修改，又或者是下载的文件块可能不完整。在这些背景下，可以通过哈希算法来做数据校验。
* 下面是 BT 协议校验的一种思路。
	* 通过哈希算法，对 100 个文件块分别取哈希值，并保存在种子文件中。因为哈希算法对数据的敏感性，即使修改了一个字符，也会引起哈希值的极大变化。所以当所有文件块下载完毕之后，使用相同的哈希算法对所有的文件块遍历取哈希值，和种子文件中保存的哈希值一一比对。如果不同，说明当前文件块不完整或者已经被篡改，需要重新从其他宿主机器上下载文件块。

### 场景四：散列函数

* 散列函数就是哈希算法的一种应用。
* 前面的章节提到，散列函数是设计散列表的关键。它直接决定了散列冲突的概率和散列表的性能。
* **而相对于哈希算法的其他应用，散列函数对散列算法冲突的容忍度会高很多，也就是要求会低很多**。即使出现冲突，只要不是十分严重，都可以通过开放寻址法或者链表法来解决。
* 而且散列函数对散列算法计算得到的值是否能反向解密也并不关心。**散列函数中的散列算法更加关注于散列后的值是否能够均匀地分布，也就是一组数据是否能均匀地散列在各个槽中。**
* 而散列函数执行的快慢也直接影响散列表的性能，因此散列**函数所使用的散列算法一般相对比较简单，更追求效率。**

## 哈希算法应对字典攻击

* 维护一个常用密码的字典表，把字典中的每个密码用哈希算法计算哈希值，然后拿哈希值和脱库后的密文比对。如果相同，基本上可以认为，加密之后的密码对应的明文就是字典中的密码。（注意，这里说是的是“基本上可以认为”，因为根据我们前面的学习，哈希算法存在散列冲突，也有可能出现，尽管密文一样，但是明文并不一样的情况。）
	* 如何理解？*比如黑客获取到的是加密后的密文。但有不少人把密码设置的很简单，例如 `000000` 或 `123456`，把这类简单的密码通过哈希算法计算哈希值之后，和黑客非法取到的密文进行比较，如果得到相同的值，就几乎可以认为是得到了原始密码。*
* **针对字典攻击，我们可以引入一个盐（salt），跟用户的密码组合在一起，增加密码的复杂度。** 我们拿组合之后的字符串来做哈希算法加密，将它存储到数据库中，进一步增加破解的难度。不过原文作者这里提到，**安全和攻击本质上是一种博弈关系，不存在绝对的安全，所有的安全措施，只是增加攻击的成本而已。**

## 小结

* 本节主要关注哈希算法的几大应用场景。
	* 1. 安全加密：任何哈希算法都会出现散列冲突，但是这类散列冲突的概率非常小。需要注意的是：
			* 越是复杂的哈希算法越难破解，但计算时间也会越长。
			* 选择哈希算法时，要权衡安全性和计算时间来决定使用何种哈希算法。
	*  2. 唯一标识：哈希算法可以对大数据做信息摘要，通过一个相对较短的二进制编码来表示极大的数据。
	*  3. 校验数据的完整性和正确性：通过数据切块后，对比每条数据的哈希值来确保网络传输没有丢包的现象。
	*  4. 散列函数：它对哈希算法的要求比较特别，更加关注散列的平均性和哈希算法的执行效率。

## 扩展

* 区块链的哈希算法是怎样的？
	* 区块链主要使用的哈希算法是：**`SHA-256` 和 `RipeMD160`。**
	* `SHA-256` 的理论碰撞概率是：尝试 2 的 130 次方的随机输入，有 99.8% 的概率碰撞。注意 2^130 是一个非常大的数字，大约是`1361万亿亿亿亿`。以现有的计算机的计算能力，是不可能在短期内破解的。
	* 比特币使用两种哈希算法，一种是对数据进行两次 `SHA-256` 计算，这种算法在比特币协议中通常被称为 `hash256` 或者 `dhash`。另一种算法是先计算 `SHA-256`，再计算 `RipeMD160`，这种算法在比特币协议中通常被称为 `hash160`。
	* 可以在浏览器控制台中直接输入以下代码查看日志。

```typescript
const
  bitcoin = require('bitcoinjs-lib'),
  createHash = require('create-hash');

function standardHash(name, data) {
  let h = createHash(name);
  return h.update(data).digest();
}

function hash160(data) {
  let h1 = standardHash('sha256', data);
  let h2 = standardHash('ripemd160', h1);
  return h2;
}

function hash256(data) {
  let h1 = standardHash('sha256', data);
  let h2 = standardHash('sha256', h1);
  return h2;
}

let s = 'bitcoin is awesome';
console.log('ripemd160 = ' + standardHash('ripemd160', s).toString('hex'));
console.log('  hash160 = ' + hash160(s).toString('hex'));
console.log('   sha256 = ' + standardHash('sha256', s).toString('hex'));
console.log('  hash256 = ' + hash256(s).toString('hex'));
```

#ALG 