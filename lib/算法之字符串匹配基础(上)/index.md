# 字符串匹配基础

## 简言

* 有关字符串算法，我们用的最多的是语言自带的字符串查找函数，例如 JS 中的 `indexOf`, `inlcudes`, Java 中的 `indexOf` 和 python 的 `find` 函数。它们底层依赖的就是我们接下来了解的字符串匹配算法。
* 字符串匹配算法的种类很多，这一节主要关注两种比较简单基础的算法，BM 算法和 RK 算法。下一节则继续深入到 BM 算法和 KMP 算法。
* 这些都是**单模式串匹配**的算法，也是一个字符串和另一个字符串匹配。后面则会介绍多模式串匹配算法，在一个字符串中查找多个串，也就是 **Trie 树和 AC 自动机**。
* 本文介绍的两个算法中，RK 算法是 BM 算法的改进。它借助哈希算法，让后者的匹配效率有较大的改进提升。

> RK 算法是如何通过哈希算法来实现高效字符串匹配呢？
> 学习曲线：★★☆

## BF 算法

* BF 算法就是 `Brute Force` 算法，暴力匹配算法，也称为朴素匹配算法。
	* 它比较简单粗暴，相应的性能也不高。

### 主串和模式串

* **主串就是被查找的字符串，模式串就是需要查找的字符串。**
	* 在字符串 A 中查找 B。
	* 此时 A 是主串，B 是模式串。
* 主串的长度记作 n，模式串的长度记作 m，在主串中查找模式串，所以 **`n > m`**, 否则查找没有意义。

### BF 算法思想

* BF 算法就是从起始位置 0、1、2 直至 `n - m + 1`, 在 n 中找出所有长度为 m 的字符串，将其和模式串一一比较，确认是否匹配。
* 观察下图来帮助理解。

![[BF算法示意图.png]]

### BF 算法的实现

* 下面是 TS 版本的实现。

```typescript
/**
 * @description: BM 查找算法实现
 * @param {string} str
 * @param {string} pattern
 * @return {number}
 */
function brutalForce(str: string, pattern: string): number {
  if (str.length === 0 || pattern.length === 0 || pattern.length > str.length) return -1;

  const sLen = str.length;
  const pLen = pattern.length;

  for (let i = 0; i < sLen; i++) {
    for (let j = 0; j < pLen; j++) {
      if (str[i + j] !== j[i]) break;

      // !匹配到最后一位字符且相等，说明已经匹配完成，返回已匹配字符的首个字符索引
      if (j === pLen - 1) {
        return i;
      }
    }
  }

  return -1;
}
```

### 时间复杂度

* 从上图可以看出，极端情况下需要比较 `n - m + 1` 次，每次模式串和子串比较 m 个字符。这种算法的最坏情况时间复杂度是 `O(n * m)`.
* BM 算法理论的最坏情况时间复杂度比较高，但在实际开发中其实还是比较常用。
* 主要是因为：
	* 实际开发中，主串和模式串的长度都不会太长；而且每次模式串和主串中的子串比较时，遇到不匹配的字符的时候就会停止，不会把所有的 m 个字符都进行比对。所以实际情况不太会变成最坏时间复杂度的情况，大部分情况的算法执行效率会比这个高很多。
	* 暴力匹配算法思想比较简单，代码实现也比较简单，不容易出错。如果出现问题也比较容易修复。在实际开发中，满足性能要求的前提下简单就是首选。这就是 **`KISS(Keep it Simple and Stupid)`** 设计原则。
* 通常情况下，BM 算法已经能够满足实际需求。

## RK 算法

* RK 全称 `Rabin-Karp` 算法，是由两位发明者的名字来命名的。
* 上文提到，BM 算法的最坏时间复杂度是 `O(m*n)`. 我们对其稍加改造，通过引入哈希算法可以大大降低时间复杂度。

### RK 算法思想

* RK 算法通过哈希算法对主串中的  `n - m + 1`  个字符串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果两者相等，就说明子串和模式串相匹配。（哈希冲突在后文会讲到）
	* 注意：是对整个同等长度的字符串求哈希值，而不是每个字符求哈希值。
	* 因为**哈希值是数字**，数字间的比较是非常快速的，这样模式串和子串的**比较效率**就会大大提高。

![[RK算法示意图.png]]

* **通过哈希算法计算哈希值，我们把模式串和子串比较的效率提高了，但是算法整体的效率并没有提高**，我们希望也能提高哈希算法计算子串哈希值的效率。

### 提升哈希算法效率

* 假设匹配的字符串的字符集中只包含 K 个字符，我们就用 K 进制来表示一个子串，把这个 K 进制数转化为十进制数，作为子串的哈希值。
* 比如要处理的字符串中只包含 a-z 这 26 个小写字母，就可以用 26 进制来表示字符串。可以把 a-z 26个字符映射到 0-25 这 26 个数字，a 表示 0，b 表示 1，以此类推，z 表示 25.
* 十进制的计算很好理解，如下面第一行公式所示。对应到 26 进制，只需要把进位 10 换成 26 来计算，具体如下所示：

![[RK算法哈希计算示意图.png]]

* 下面的例子中，我们都假设字符串只包含小写字母 a-z，方便理解。而在这种哈希算法里，主串中两个相邻的子串的哈希值计算公式是有关系的。
	* 观察下面的图来查找规律。

![[RK算法哈希计算示意图2.png]]

* 可以发现的规律是，相邻两个子串 `s[i-1]` 和 `s[i]`（i 表示子串在主串中的起始位置，子串的长度都为 m）, 对应的哈希值计算公式有交集。可以使用 `s[i-1]` 的哈希值很快计算出 `s[i]` 的哈希值。
* 下面就是用公式表示的内容：

![[RK算法哈希计算示意图3.png]]

* 我们可以通过事先计算好 26 次方的值并存储的方式来提高效率。后续就可以直接查表获取值。我们先计算好 26 的 0 次方、1 次方、2 次方、3 次方、直至26^(m-1) ，存储在长度为 m 的数组中，数组的下标对应公式的次方。当需要计算 26 的 x 次方的时候，就从数组下标 x 的位置取值，直接使用省去了计算时间，从而提高效率。

![[RK算法查表.png]]

### RK 算法的实现

* 下面是 RK 算法的 TS 实现。

```typescript
/**
 * @description: 创建字母的映射
 * @return {Record<string, number>}
 */
function createMapping(): Record<string, number> {
  const mapping: Record<string, number> = {};
  for (let i = 0; i < 26; i++) {
    const letter = String.fromCharCode('a'.charCodeAt(0) + i);
    mapping[letter] = i;
  }
  return mapping;
}

const Mapping = createMapping();
const LEN = 26;

/**
 * @description: 获取哈希值
 * @param {string} str
 * @return {number}
 */
function getHash(str: string): number {
  let value = 0;
  const sLen = str.length;

  for (let i = 0; i < sLen; i++) {
    value += Mapping[str[i]] * LEN ** (sLen - i - 1);
  }

  return value;
}

/**
 * @description: rk 算法的实现
 * @param {string} str
 * @param {string} pattern
 * @return {number}
 */
function rk(str: string, pattern: string): number {
  const sLen = str.length;
  const pLen = pattern.length;
  const pHash = getHash(pattern);
  let sHash = getHash(str.slice(0, pLen));

  for (let i = 0; i <= sLen - pLen; i++) {
    // 哈希值相等，直接匹配成功
    if (pHash === sHash) {
      return i;
    }
    // 通过首尾字符的变化，重新计算哈希值
    sHash = (sHash - Mapping[str[i]]) * LEN ** (pLen - 1) * LEN + Mapping[str[i + pLen]];
  }

  return -1;
}
```

### RK 算法的时间复杂度

* RK 算法包含两部分：**计算子串哈希值和模式串哈希值与子串哈希值间的比较。**
	* 前面分析到，通过特定的哈希算法，可以只扫描一遍主串就计算出所有子串的哈希值，这部分的时间复杂度是 `O(n)`.
	* 模式串哈希值与每个子串哈希值之间的比较的时间复杂度是 `O(1)`, 总共需要比较 `n - m + 1`，所以这部分的时间复杂度也是 `O(n)`.
* 综上，**RK 算法的时间复杂度就是 `O(n)`.**

### RK 算法的溢出

* 刚才我们提到的 RK 算法是比较理想的情况。实际中，可能存在字符串超长的情况，主串和子串都可能很长，那么计算出的哈希值就会很大，甚至可能会超出计算机所能表示的最大整型数。
	* 例如上文中 26 的指数级增长是非常大的，10 位的字符串表示出来的值就会非常巨大。而实际中的数字显然会更大。
* 这时就需要注意散列冲突，上文我们在理想情况下不会出现散列冲突，但在实际开发中不可避免会出现散列冲突。我们需要散列冲突来避免计算溢出的情况。
* 同样，刚才的哈希算法也可以优化，刚才我们用 26 的次方的形式来计算哈希值。其实可以更简便一些，**直接取每个字母对应的数字，把模式串或子串中所有字母所对应的数字相加得到和，这个和就可以作为哈希值**。这种算法生成的哈希值就会小很多。
	* *而这种场景下的哈希值可能会出现比较多的散列冲突，我们就可以**把字母对应的数字改成互不相同的素数**，这样就可以大大减少冲突概率。*

#### RK 算法的哈希冲突

* 我们提到了允许散列冲突，也就是假如模式串的哈希值与子串的哈希值相等，但模式串和子串仍有可能是不相等的。这时的解决方案很简单，就是**直接比较原字符串**。
* 如果两者的哈希值不相等，那么模式串和子串本身肯定也不相等，就不需要比较原字符串。
* 因此，哈希算法的冲突概率要尽可能控制地较低。如果存在大量冲突，就会导致执行效率变低，大多数时候因为哈希值相等，实际比较的仍然是原来的模式串和子串，那么哈希算法的意义就不大了，而且会导致时间复杂度降回到 `O(n*m)`.
* 通常情况下，RK 算法的效率还是比 BF 算法高。

## 小结

* 这节主要关注两种字符串匹配算法：BF 算法和RK 算法。
* BF 算法是最简单粗暴的字符串匹配算法。
	* 实现思路是，把模式串和主串中的所有长度相同的子串相匹配，确认是否有匹配的子串，这种情况下时间复杂度也会比较高，是 `O(n*m)`. n 和 m 分别表示主串和模式串的长度。
	* 而因为这种算法实现简单，对于处理小规模的字符串匹配很好用。
* RK 算法是借助哈希算法对 BF 算法进行优化改造。即每个子串分别求出哈希值，再把每个子串的哈希值和模式串的哈希值进行比较，数字的比较可以大大减少比较时间。
	* 理想情况下，RK 算法的时间复杂度是 `O(n)`.
	* RK 算法的执行效率取决于哈希算法的设计。哈希冲突较多的话，时间复杂度会退化，存在大量冲突的话，时间复杂度会降为 `O(n*m)`.

## 扩展

* 这两种算法实际都可以类比到二维空间。假设有以下一个二维字符串矩阵（主串），如何在其中查找另一个二维字符串矩阵（模式串）？
	* 💭
![[字符串匹配算法矩阵示意图.png]]

#ALG 