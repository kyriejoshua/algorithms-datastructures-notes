# 贪心算法

## 简言

* 接下来学习四种更加基本的算法，或者说是算法思路：贪心算法、分治算法、回溯算法、动态规划。

> 学习曲线：★★★★

## 贪心算法的核心理念

* **贪心算法（`greedy algorithm`）就是每次都选择当前场景下的最优解，最终统筹每一个局部最优解，得到全局最优解。**

### 贪心算法的应用场景

* 下面是通常情况下贪心算法的解决步骤：
	* **这类问题首先可以联系到贪心算法：针对一组数据，我们定义了限制值和期望值，期望从中选出部分数据，这些数据在满足限制值的情况下，期望值最大。**
	* **确认这个问题是否可以用贪心算法解决：每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据。**
	* **举几个例子确认贪心算法得到的结果是否是最优的结果：大部分情况下，只需要几个例子验证通过就可以。** 因为严格证明贪心算法的正确性是非常复杂的，会涉及到比较多的数学推理。从实践角度上看，大部分能用贪心算法解决的问题，其**正确性都是显而易见的**，并不需要严格的数学证明。
* 但贪心算法解决问题的思路，并不一定就能得出最优解。
	* 下面是贪心算法失策的案例，图片中是一个有权图：

![[贪心算法失策案例.png]]

* 在上图中求顶点 S 到顶点 T 的最短路径。如果我们每次都取最短的路径，得到的结果却不是最短的。
	* 第一次我们选择权重最小为 1 的边；
	* 第二次我们选择权重最小为 4 的边；
	* 第三次同上；
	* 路径是 `S - A - E - T`, 得到的结果是 `1 + 4 + 4 = 9`.
* 但我们稍加观察就可以发现，最短路径的组合是 `S - B - D - T`, 长度结果是 `2 + 2 + 2 = 6`.
* 这个问题贪心算法不成功的主要原因是前面的选择会影响后面的选择。显而易见，上面的有权图的每次选择都会影响剩下的选择，如果其中有一步是最优解却导致剩下的全是糟糕的解法，也就会无法得到全局的最优解。

## 贪心算法实战分析

* 下面通过三个示例来理解贪心算法的实战。

### 分糖果

* 这个例子可以参照 [LeetCode-455](https://leetcode-cn.com/problems/assign-cookies/) 分发饼干。其中解题思路就完全是贪心算法的应用。

#### LeetCode

* 参考代码如下，只是其中一种解法：

```typescript
/**
 * @description: 贪心算法的经典案例
 * @param {number[]} g
 * @param {number[]} s
 * @return {number}
 */
function findContentChildren(g: number[], s: number[]): number {
  /**
   * @description: 实现一个简易快排
   * @param {number[]} arr
   * @return {number[]}
   */
  function quickSort(arr: number[]): number[] {
    if (arr.length <= 1) return arr;
    // 获取分区索引
    const pivotIndex = Math.floor(arr.length / 2);
    // 获取分区值
    const [pivot] = arr.splice(pivotIndex, 1);
    const left: number[] = [];
    const right: number[] = [];

    for (const val of arr) {
      if (val <= pivot) {
        left.push(val);
      } else {
        right.push(val);
      }
    }

    return [...quickSort(left), pivot, ...quickSort(right)];
  }

  // 把孩子们和糖果排序
  const sortedG = quickSort(g);
  const sortedS = quickSort(s);
  let startIndex = 0;
  // 遍历所有糖果，查看是否满足，如果糖果超过人数就直接返回结果
  for (const candy of sortedS) {
    if (startIndex >= sortedG.length) return startIndex;
    if (candy < sortedG[startIndex]) {
      continue;
    }
    startIndex++;
  }

  return startIndex;
}
```

### 钱币找零

* 每次都选择金额最大但不超出范围的纸币。

#### LeetCode

* [LeetCode-860](https://leetcode.cn/problems/lemonade-change/): 柠檬水找零。钱币找零的经典应用。
	* 这道题比较简单，在于一开始就可以确认使用贪心算法的思路，以及求局部最优解的方式的步骤也比较简单。
	* 自己一开始做错的原因主要是用数组去存储零钱，而这里使用变量直接存储零钱就可实现。

### 区间覆盖

* 假设有 n 个区间，区间的起始端点和结束端点分别是 `[l1, r1]`, `[l2, r2]`, `[l3, r3]`,...`[ln, rn]`. 我们从这 n 个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间？

![[区间覆盖.png]]

* 这类处理思想就是用来解决经典的教师排课，任务调度等问题。
* 我们假设 n 个区间中，最左端点是 `lmin`, 最右端点是 `rmax`.这个问题就是，我们选择几个不相交的区间，来从左到右把 `[lmin, rmax]` 覆盖上。我们按照起始端点从小到大的顺序对这 n 个区间排序。
* 我们每次选择的时候，左端点和前面的已经覆盖的区间不重合的，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间。这就是贯彻着贪心的理念。

![[区间覆盖示意图.png]]

#### LeetCode

* [LeetCode-435](https://leetcode.cn/problems/non-overlapping-intervals/): 无重叠区间
* 这道题目也是贪心算法的实际应用，思路和上面的解析类似。当然这道题也是可以用动态规划来实现的。
* 下面是贪心的解法：TODO

```typescript

```

## 霍夫曼编码

* 假设有一个包含 1000 个字符的文件，每个字符占 1 个 `byte`(`1byte=8bits`),存储这 1000 个字符就一共需要 `80000bits`，有没有更加高效的存储方式？
* 假设我们通过统计发现，这一千个字符里只包含六种不同的字符，分别是 a、b、c、d、e、f。那么通过 3 个二进制位(`3bit`)就可以表示 8 个不同的字符。我们通过 3 个二进制位来标识这些字符，那么存储 1000 个字符就只需要 `3000bits` 就可以，比原来节省很多空间。

```shell
a(000), b(001), c(010), d(011), e(100),f(101)
```

* 当然还可以有更加高效的压缩方式，那就是**霍夫曼编码。它广泛应用于数据压缩中，压缩率通常在 20%~90%之间，并且是无损压缩。**
* **霍夫曼编码会考察文本中有多少个不同的字符，以及每个字符出现的频率，根据频率的不同，选择不同长度的编码。**
	* *霍夫曼通过这种不等长的编码方法，来增加压缩的效率。*
	* *根据贪心的思想，我们把出现频率较多的字符，用短一些的编码来替代，出现频率比较少的字符，用稍微长一些的编码。*
* 对于等长的编码而言，压缩起来比较简单。例如上文中的六个字母使用三个二进制位来存储，每次从文本中读取 3 位二进制码再翻译成对应的字符即可。但是霍夫曼编码支持不等长的场景，每次读取的位数是不固定的。这个问题导致霍夫曼编码压缩起来会比较复杂一些，为了避免歧义，**霍夫曼编码要求每个字符的编码之间，不会出现一个编码是另一个编码的前缀这种情况。**

![[二进制简易编码.png]]

* 假设 6 个字符的出现频率从高到底分别是 a，b、c、d、e、f。我们**用以下方式编码，避免任何一个字符的编码是另一个字符编码的前缀情况。而解压缩的时候，我们每次都会读取尽可能长度的可解压的二进制串，所以解压缩的时候也不会出现歧义。**

![[霍夫曼编码示意图.png]]

* 经过这种压缩之后，这 1000 个字符只需要 `2100bits` 就可以存储。

### 霍夫曼编码的核心

* 这里的关键就在于，如何根据字符出现频率的不同而给不同的字符进行不同长度的编码呢？
* 我们**把每个字符看作一个节点，并且把频率放到优先级队列中（堆的结构），从队列中取出频率最小的两个节点 A、B，然后新建一个节点 C，把它的频率设置为两个节点的频率之和，并且把这个节点作为节点 A、B 的父节点。最后把 C 节点放入到优先级队列中，重复这个过程，直到队列中没有数据。**

![[霍夫曼编码使用优先级队列计算.png]]

* 随后，**我们给每一条边加上权值，指向左子节点的边都标记为 0，指向右子节点的边统统都标记为 1，那么从根节点到叶节点的路径就是叶子节点字符所对应的霍夫曼编码。**
* **越下面的节点出现的频率越低，也就是层数越多的节点出现频率越低，编码也就越长。**

![[霍夫曼编码后的二叉树结构.png]]

### 霍夫曼编码讲解视频

* 图文可能不好理解，可以观看下面的视频帮助理解。

<iframe src='https://player.bilibili.com/player.html?bvid=BV1c64y1r7Sc&cid=353763307&page=1&share_source=copy_web' scrolling='no' border='0' frameborder='no' framespacing='0' allowfullscreen='true' width="100%" height="520px"></iframe>

## 小结

* 贪心算法的实际应用场景是比较有限的。它其实更像是一种思想或是解题思路，作为指导设计基础算法。比如最小生成树算法、单源最短路径算法，这些算法都用到贪心算法。
* 贪心算法的理解可以依靠大量的锻炼和练习，而不是刻意去记它的原理。
* 贪心算法的**难点在于如何把问题抽象转化成贪心算法模型**，在抽象之后，贪心算法的编码实现就会容易很多。
* 贪心算法的正确性在很多时候是很显而易见的，但是要严谨地证明并不容易。因此更多时候我们采取举反例的方式来验证贪心算法是否是最优解即可。

## 扩展

### 移除 k 个数

* *在一个非负整数 a 中，我们从中移除 k 个数字，让剩下的数字最小，如何选择移除哪 k 个数字？*
	* 错误思路：~~每次移除前 k 位数字中最大的！~~
	* 例如 391578943 中移除 5 个数字；或者在 5397281943 中移除 3 位。
		* 391578943 -> 31578943 -> 3157943 -> 315743 -> 31543 -> **1543**.
		* 5397281943 -> 537281943 -> 53281943 -> **3281943**.
	* **正确思路，使用贪心+单调栈。具体可以查看 [LeetCode-402](https://leetcode-cn.com/problems/remove-k-digits/) 题解。**
		* 具体实现代码及使用日志如下。

	```typescript
	/**
	 * @description: 贪心+单调栈的思路
	 * 时间复杂度 O(n)
	 * 空间复杂度 O(n)
	 * @param {string} num
	 * @param {number} k
	 * @return {string}
	 */
	function removeK(num: string, k: number): string {
	  // 如果移除的位数都超过当前字符串的长度，相当于直接移除所有
	  if (k > num.length) return '0';
	
	  let stack: string[] = []; // 用作栈
	  let removedK = k; // 当前可移除的 k 位数字
	  for (const digit of num) {
	    // !满足栈尾的条件大于当前数字的，就弹出，并通过 removedK - 1 来标记已弹出    
	    // !内容是单个数字的字符串可以直接比较
	    // !注意使用循环弹出所有比当前数大的满足条件的数
	    while (stack.length && stack[stack.length - 1] > digit && removedK) {
	      stack.pop();
	      removedK -= 1;
	    }
	    // 往栈中推入符合大小的数字
	    stack.push(digit);
	  }
	
	  // 如果还可以移除 removedK 位数字，就继续移除
	  while (removedK) {
	    removedK--;
	    stack.pop();
	  }
	  
	  let isFirstDigit = true;
	  let ans = '';
	  for (const digit of stack) {
	    // 首位为 0 的特殊情况不拼入字符
	    if (isFirstDigit && digit === '0') continue;
	    isFirstDigit = false;
	    ans += digit;
	  }
	
	  return ans === '' ? '0' : ans;
	}
	
	console.log(removeK('10300', 2)); // 0
	console.log(removeK('10300', 1)); // 300
	console.log(removeK('19360', 1)); // 1360
	console.log(removeK('19360', 3)); // 10 
	console.log(removeK('19360981', 3)); // 10981
	console.log(removeK('89360981', 5)); // 81
	console.log(removeK('893627981', 4)); // 27981
	```

### 窗口等待时间

* *假设有 n 个人正在等待服务，但服务窗口只有一个，每个人需要服务的时间也并不相同，如何安排服务的先后顺序，才能让 n 个人总的等待时间最短？*
	* 每次让当前所需服务时间最短的人先进行服务；个人理解这个场景类似于超市结账，大部分人会希望购买物品少的人优先结账，这样焦急等待的人会减少许多。

#ALG 