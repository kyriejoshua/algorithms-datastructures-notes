# 跳表（Skip list）

> 学习曲线：★★★☆

## 如何理解跳表

* 跳表全称为**跳跃链表**。
* 个人理解：**跳表的核心是对有序链表建立索引，通常是对*有序单链表*建立索引。索引是多级的，分为一级二级等等，可以每隔两个建立索引，也可以每隔三个建立索引，一直建立到某一层级的索引数小于等于间隔的数量。**
* Redis 中的有序集合就是使用跳表实现的。

### 跳表解决的问题

* **跳表核心解决的是单链表中查询的复杂度较高的问题，也就是提高查找的效率。**
* 单链表在默认情况下的查找时间复杂度是 `O(n)`. 可以通过跳表来降低时间复杂度。
* 原始的单链表如下：

![[跳表的原始链表.png]]

* 我们对其建立每隔两个的索引，主要是新建索引结点，并且索引结点中新增 `down` 指针指向原始链表的结点：

![[跳表建立一级索引.png]]

* 在原始链表中，查找值 16 需要遍历 **10** 个结点。
* 建立一级索引之后，只需要遍历 **7** 个结点。
* 如果我们再建立一级索引的话呢。

![[跳表建立二级索引.png]]

* 可以看到，现在只需要遍历 **6** 个结点，比之前更少。
* 因为这里的数据量本身比较小，所以可以看到的提升不够明显。我们把数据稍微放大一些来观察提升的效率变化。
* 下面是 64 个结点的链表，并建立五级索引。

![[较大的跳表.png]]

* 在五级索引下，可以发现只需要查找 11 个结点就能确认 62 的位置。
* 当链表长度达到 1000、10000 甚至更大的时候，提升的效率就会更加明显。
* 所以这种**链表添加多级索引的结构就是跳表。**

### 跳表对查询效率的提升

* 我们可以直接理解为如何分析具有多级索引的跳表的时间复杂度。

#### 跳表的时间复杂度

* 分解问题，可以先确认跳表的索引层级数量。时间复杂度一定和索引层级的数量有关。
* 问题转变为，在 n 个结点下，有多少层索引？
	* 一级索引，有 `n / 2` 个结点，二级索引，有 `n / 4` 个索引，依次减少，规律就是每一级是上级的 `1 / 2`.
	* 第 k 级索引的节点个数是 `k - 1` 级索引的结点个数的 `1 / 2`. 第 k 级索引结点的个数就是 `n / (2^k)`.
	* 假设最高一级的索引是 2 个结点，那么可以推断 `n / (2^k) = 2`, 转化成 `k = log₂n - 1`. k 是索引的层级，再加上原始链表的一层，就是 `log2n`. 这就是跳表的高度。
* 在跳表中查询，每个层级都要遍历 m 个结点，在跳表中查询一个数据的时间复杂度就是 `O(m * logn)`.
* 现在的问题是， m 的值是固定的吗？它的值是多少。以上面每层是上层的二分之一的这种建立索引的方式实现的跳表为例，`m = 3`. 那么这个值是怎么得到的呢？
	* 假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 `down`  指针，从第 k 级索引下降到第 `k - 1` 级索引。在第 k - 1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 `k - 1` 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点。
		* 个人理解，*跳表向上建立索引，按照每隔两个建立索引的规律，那么最上面一层的结点数量不是 2 个 就是 3 个。在最上层结点数是 2 个的时候，每层索引最大遍历数 m = 2. 最上层结点数是 3 个的时候，每层索引最大遍历数 m = 3.*
		* 在最上层索引是 3 个结点的时候，是否还有必要再建立索引目前没有确切资料说明。个人觉得是没有必要再建立索引。

![[跳表的查询m值.png]]

* 通过上面的分析，可以知道**跳表中查询任意数据的时间复杂度是 `O(logn)`.**
* *跳表为了提升效率，建立多级索引，实际上也是**空间换时间的思想**。*
* 下面就来分析具体的空间复杂度。

#### 跳表的空间复杂度

* 假设原始链表大小为 n，那第一级索引大约有 `n / 2` 个结点，第二级索引大约有 `n / 4` 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。如果我们把每层索引的结点数写出来，就是一个等比数列。

![[分析跳表的空间复杂度.png]]

* 这几级索引的结点总和就是 `n / 2 + n / 4 + n / 8 …+8 + 4 + 2 = n - 2`。所以，跳表的空间复杂度是 `O(n)`。
	* 可以代入 32 或 64 这样的数字进行计算和验证。
		* n = 32 时，16 + 8 + 4 + 2 = 30 也就是 n - 2.
	* 这里的空间复杂度是基于每隔两个建立索引的跳表来计算的。
* 下面是每隔三个结点来建立索引。计算的基准就有所不同，但核心也是等比数列累加的计算。
	* `n / 3 + n /9 + n / 27 ... + 3 + 1`
	* 同理，可以计算得到结果是 `n / 2`.

![[优化跳表的空间复杂度.png]]
* 尽管空间复杂度还是 `O(n)`. 但它比前一个每两个结点构建一个索引结点的方式，实际占用的结点是减少了一半的索引构建。
* 实际开发中，不用太在意索引占用的额外空间。因为在实际的软件开发中，要处理的数据往往不是简单的整数，而是对象，索引结点只需要存储关键值和指针，而不需要存储对象。
	* **当对象比索引结点大很多时，索引占用的额外空间就可以忽略不计。**

## 跳表高效的动态插入和删除

* 跳表不仅提升链表中查询的效率，也能支持数据动态的插入和删除操作，并且时间复杂度是 `O(logn)`.
* 之前提到，链表的插入操作本身的时间复杂度是 `O(1)`.
* 那么查询后插入的时间复杂度就是 `O(1) * O(logn) = O(logn)`.

![[跳表的插入.png]]

* 删除操作的不同之处在于，除了要删除原始链表中的结点，还需要删除索引中的结点（如果有的话）。
	* 而且还需要查找到删除结点的前驱结点，这样才能实际进行删除操作。
	* 从实现上来看，删除结点就是直接删除对应结点以及跨越的层数删除。可以查看下文的视频来帮助理解。
* 💭 原文这里没有对于删除操作的时间复杂度的分析。

### 跳表索引动态更新

* 在跳表中插入数据，如果不更新索引，可能会出现两个索引结点之间出现非常多的结点的情况。*极端情况下，跳表会退化成单链表。*

![[跳表的索引中间隔过多结点.png]]

* 作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点变多，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。
* 在跳表中，有一个随机函数来决定把这个结点插入到哪几级索引中。随机函数返回 K，就插入到 K 级索引中。
	* 这个意思是，**从上往下插入到 K 级索引，K - 1 级和 K - 2 级等等直到原始链表。**

![[跳表的随机插入.png]]

#### 跳表的随机插入函数

* 跳表的随机插入函数简单实现如下：

```typescript
/**
 * @description: 随机生成索引层级
 * @param {number} maxLevel
 * @return {number}
 */
function randomLevel(maxLevel: number): number {
  const MAX_LEVEL = maxLevel || 16; // 设置最大层级，避免溢出
  let level = 1;
  for (let i = 0; i < MAX_LEVEL; i++) {
    if (Math.random() < 0.5) {
      level++;
    }
  }

  return level;
}
```

### 跳表的实现

* 跳表本身的实现也是比较复杂的，因而也没有展开。可以留作后续实现。
	* 💭 TS 实现跳表数据结构。[占位符](https://github.com/kyriejoshua/javascript-datastructure/blob/main/src/SkipList/index.ts)

## 跳表的视频讲解

* 这个视频比较通俗易懂的讲解了跳表这种数据结构。

<iframe src='https://player.bilibili.com/player.html?bvid=BV1QK4y1Y7mS&cid=227099751&page=1&share_source=copy_web' scrolling='no' border='0' frameborder='no' framespacing='0' allowfullscreen='true' width="100%" height="520px"></iframe>

## 跳表在 Redis 中的应用

* Redis 的有序集合支持的核心操作是：
	* **插入数据**
	* **删除数据**
	* **查找数据**
	* **按照区间查找数据**
	* **迭代输出有序序列**

### 跳表相比红黑树的优势

* 其中，除了区间查找，其他都可以用红黑树来完成，而且时间复杂度一样。但是*按照区间查找数据这个操作，红黑树的效率没有跳表高。*
* Redis 之所以用跳表来实现有序集合，还有其他原因。
	* 比如，*跳表更容易使用代码实现*。虽然跳表的实现也不简单，但比起红黑树来说还是相对容易，而简单就意味着可读性好，不易出错。
	* 还有，*跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。* 如果空间足够，就可以建立非常多层级的索引；如果空间较少，就建立较少层级或者更大间隔区间的索引。
* 跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。在业务开发时，直接使用就可以，不用自己手动实现，但是跳表并没有一个现成的实现，所以在开发中，如果想使用跳表，必须要自己开发实现。

## 小结

* 跳表使用空间换时间的设计思路，通过构建多级索引来提高查询的效率，实现了基于链表的“二分查找”。跳表是一种动态数据结构，支持快速地插入、删除、查找操作，时间复杂度都是 `O(logn)`。
* 跳表的空间复杂度是 `O(n)`。不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。
* 跳表和红黑树比较类似，但是很多时候为了代码的简单易读，比起红黑树，会更倾向于使用跳表。

## 扩展

* 分析每 3 个或 5 个结点提取结点作为上级索引的跳表的查询的时间复杂度。
	* 猜测：`O(m * log₃n)`, 每隔 3 个时，m = 4. 本质上还是 `O(logn)`.

#ADT #ALG 
