# 复杂度分析之理论

## 为什么需要复杂度分析？

* **在实践中，把代码执行一遍，通过统计和监控等手段，就可以得到算法执行的时间和内存占用的大小。**
	* 这种方式称为**事后统计法**。
* 有这样一种较为准确的分析方法，为什么还需要时间复杂度和空间复杂度的分析呢？
* 因为这种方法也有着它的局限性。
* 事后统计法的两点局限性：
	1. 测试结果非常依赖测试环境。
	2. 测试结果受数据规模的影响很大。

### 测试结果非常依赖测试环境
* 测试环境中硬件的不同会很大程度上影响代码的执行结果。例如在 *Intel Core i9* 处理器和 *Intel Core i3* 处理器上的执行结果显然会有所不同。i9 的执行速度会快很多。
* 当然也可能原本在 a 机器上代码执行较快，在 b 机器上执行又变得很慢。

### 测试结果受数据规模的影响很大

* 对同一个排序算法，待排序数据的**有序度**不一样，排序的执行时间也会有很大的差别。
	* 极端情况下，数据本身就是有序的，那么排序算法不需要做任何操作，执行时间就会非常短。
* 而且，如果测试数据的规模太小，测试结果可能无法真实反映算法的性能。
	* 例如，对于小规模的数据排序，插入排序可能会比快速排序还快。
* 因此，**我们需要一个不用具体的测试数据来测试，就可以粗略估计算法的执行效率的方法。** 这就是这节关注的重点。

## 大 O 复杂度表示法

* 观察下面这段代码：

```typescript
function cal(n: number): number {
  let sum = 0;
  let i = 1;
  for (; i <= n; ++i) {
	  sum = sum + i;
  }
  return sum;
}
```

* 这段代码每一行都执行类似操作：*读数据-运算-写数据。*
* 实际上每行代码对应的 CPU 执行的个数、执行的时间都不一样。但这里是粗略的估计，所以可以假设每行代码的执行的时间都一样，为 `unit_time`. 在这个基础上，可以试着分析这段代码的总的时间复杂度。
* 第 2、3 行代码分别需要 1 个 `unit_time` 的执行时间，第 4、5 行都运行了 n 遍，需要 `2n * unit_time` 的执行时间。
* 总的代码的时间复杂度就是 `(2n+2) * unit_time`。
* 可以发现，***所有代码的执行时间 `T(n)` 与每行代码的执行次数成正比。***
* 按照这个思路，下面的这段代码的时间复杂度是多少呢。

```typescript
function cal(n: number) {
  let sum = 0;
  let i = 1;
  let j = 1;
  for (; i <= n; ++i) {
	  j = 1;
	  for (; j <= n; ++j) {
	  	 sum = sum +  i * j;
	  }
  }
}
```

* 我们仍然假设每个语句的执行时间是 `unit_time`. 现在再来求得执行时间 `T(n)`.
	* 第 5、6 行代码执行了 n 遍，需要 `2n * unit_time` 的执行时间；
	* 第  7、8 行代码循环执行了 `n^2`，所需时间就是 `2(n ^ 2) * unit_time`. 所以总的执行就是 `(2(n^2) + 2n+3) * unit_time`.
* 虽然不能确认 `unit_time` 的具体时间，但是通过这个推导过程可以得出一个重要的规律：
	* **所有代码的执行时间 T(n) 和每行代码的执行次数 f(n) 成正比。**
* 把这个规律可以总结成公式：

![[时间复杂度公式.png]]

* 其中，**T(n) 表示代码执行的时间，n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。** 因为这是公式，所以用 f(n) 来表示。
	* **公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。**
* 上面第一个例子中的 `T(n) = O(2n + 2)`, 第二个例子 `T(n) = O(2(n^2) + 2n + 3)`. 这就是大 O 时间复杂度表示法。
* **大 O 时间复杂度表示的不是代码真正的执行时间，而是表示代码执行时间随着数据规模增长的变化趋势。** 因此也叫做**渐进时间复杂度**。
* *当 n 很大时，公式中的低阶，常量，系数三部分并不会左右增长趋势，因此都可以忽略。* 我们只需要记录最大量级就可以了。如果用大 O 表示法表示上面两个案例的时间复杂度，就可以记为
	* **`T(n) = O(n)`**
	* **`T(n) = O(n^2)`**

### 时间复杂度分析

* 上面主要介绍了大 O 复杂度的由来和表示方法。下面来介绍如何进行具体的时间复杂度分析。
* 这是三个实用的复杂度分析方法，需要综合一起使用。

#### 1. 只关注循环执行次数最多的一段代码

* **如果代码里有多处循环，只关注循环最多的一次，以此来确认复杂度。**
* 例如上文中的代码，其实只需要关注循环里的代码即可。

#### 2. 加法法则：总复杂度等于量级最大的那段代码的复杂度

* **有多个不同量级的独立的循环，则取最大量级的作为复杂度结果。**
* 观察下面这段代码:

```java
int cal(int n) {
 int sum_1 = 0;
 int p = 1;
 for (; p < 100; ++p) {
	 sum_1 = sum_1 + p;
 }

 int sum_2 = 0;
 int q = 1;
 for (; q < n; ++q) {
	 sum_2 = sum_2 + q;
 }

 int sum_3 = 0;
 int i = 1;
 int j = 1;
 for (; i <= n; ++i) {
	 j = 1; 
	 for (; j <= n; ++j) {
		 sum_3 = sum_3 +  i * j;
	 }
 }

 return sum_1 + sum_2 + sum_3;
}
```

* 这段代码可以分为三部分，分别求 `sum_1` 和 `sum_2` 和 `sum_3`。我们可以分析每个部分的时间复杂度，再放到一起比较，取最大的作为整段代码的时间复杂度。
* 第一段的代码执行 100 次，是常量级别的执行时间，和 n 的规模无关。
	* **常量的数据规模不论多大，都可以忽略掉，因为他本身对增长趋势没有影响。**
* 第二段和第三段的时间复杂度是 `O(n)` 和 `O(n^2)`.
* 结合三段代码的时间复杂度，取其中最大的量级。因此整段代码的时间复杂度就是 `O(n^2)`.
	* **总的时间复杂度等于量级最大的代码片段的时间复杂度。**
* 把这段总结抽象成公式就是：
	* **如果 `T1(n) = O(f(n))`, `T2(n) = O(g(n))`; 那么 `T(n) = T1(n) + T2(n) = max(O(f(n), O(g(n))) = O(max(f(n), g(n)))`.**

#### 3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

* **适用于循环中又套了循环，则总复杂度等于内外复杂度的乘积。**
* 类比上文中的加法法则公式，也可以很快写出乘法法则的公式：
	* **如果 `T1(n) = O(f(n))`, `T2(n) = O(g(n))`; 那么 `T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O(f(n) * O(g(n)))`. **

## 常见的时间复杂度实例分析

* 时间复杂度全称是**渐进时间复杂度**，表示算法的**执行时间**与**数据规模**之间的增长关系。

![[复杂度量级.png]]

## 多项式量级和非多项式量级

* 这两者分别对应上图的左右两侧。

### 非多项式量级

* `O(2^n)` 就是 2 的 n 次方
* `O(n!)` n 的阶乘
* **非多项式量级的算法执行时间会随着 n 的增大而无限增长，所以是非常低效的算法。**

### 多项式量级

#### O(1)

* 代码的执行时间不随着 n 的增大而增长，这种代码的时间复杂度都记作**常量阶** `O(1)`.
	* **它表示的是常量级时间复杂度，并不意味着实际只执行了一行代码。**
	* *一般情况下，只要算法中不存在循环语句，递归语句，即使代码量成千上万，时间复杂度也是 `O(1)`.*

#### O(n)

* **线性阶**常用在一次遍历的时候。

```typescript
/**
 * 算法复杂度 O(n)
 * @param arr 
 * @param fn 
 */
function forEach(arr: any[], fn) {
  console.info('callback', fn);
  for (let i = 0; i < arr.length; i++) {
    fn && fn(arr[i]);
  }
}
```

#### O(logn)/O(nlogn)

##### O(logn)

* **对数阶**时间复杂度非常常见，但也比较难分析。
* 对数阶的时间复杂度通常都记为 `O(logn)`, 例如二分法。

```typescript
 let i = 1;
 while (i <= n)  {
   i = i * 2;
 }
```

* 上文 i 的取值就是等比数列。高中数学学过等比数列，根据 `2x = n` 可以求得 `x = log₂n`. 因此这段代码的时间复杂度就是 `O(log₂n)`.

![[时间复杂度求和成等比数列.png]]

* 如果把上文中 `i * 2` 改为 `i * 3`，代码的时间复杂度就会变为 `O(log₃n)`.
* *不管以几为底，所有对数阶的时间复杂度都可以记为 `O(logn)`.*
* 这是为什么呢？因为对数之间是可以转换的， `log₃n` 等于 `log₃2 * 2n`, 所以 `O(log₃n) = O(C * log₂n)`. 
	* 其中 **`C = log₃2`** 是一个常量。基于前面的理论，采用大 O 表示法的时候，可以忽略常量系数，即 **`O(C * f(n)) = O(f(n))`**.
	* 所以，`O(log₂n)` 就等于 `O(log₃n)`.
* 在对数阶时间复杂度的表示方法里，我们忽略对数的底，统一表示为 `O(logn)`.

##### O(nlogn)

* 而如果循环了 n 遍 `O(logn)`，根据乘法法则，那么算法时间复杂度就会变成 `O(nlogn)`.
* 下面是两种复杂度为 `O(nlogn)` 的排序实现：**快速排序和归并排序**。
* **快速排序**如下：

```typescript
/**
 * 快速排序 复杂度 O(nlogn)
 * @param arr 
 * @returns 
 */
function quickSort(arr: number[]): number[] {
  // 递归的终止条件
  if (arr.length <= 1) {
    return arr;
  }
  const midIndex: number = Math.floor(arr.length / 2);
  const baseVal: number = arr.splice(midIndex, 1)[0];
  let left: number[] = [];
  let right: number[] = [];

  for (let i = 0; i < arr.length; i++) {
    const item = arr[i];
    if (item < baseVal) {
      left.push(item)
    } else {
      right.push(item);
    }
  }

  return quickSort(left).concat(baseVal).concat(quickSort(right));
}

quickSort([4, 12, 1, 3, 2, 7]);
```

* **归并排序**如下：

```typescript
/**
 * 自上而下递归的归并排序
 * 时间复杂度 O(nlogn)
 * @param arr 
 * @returns 
 */
function mergeSort(arr: number[]): number[] {
  // 如果数组已进入最小粒度，则直接返回副本
  if (arr.length < 2) {
    return arr.slice();
  }
  const mid: number = Math.floor(arr.length / 2);
  let res: number[] = [];
  // 取中间值将其拆分成左右，自上而下地进行递归
  let left: number[] = mergeSort(arr.slice(0, mid));
  let right: number[] = mergeSort(arr.slice(mid));

  while (left.length && right.length) {
    // 比较大小并放入最终的结果
    if (left[0] <= right[0]) {
      res.push(left.shift());
    } else {
      res.push(right.shift());
    }
  }

  // 将所有结果联结
  res = res.concat(left).concat(right);

  return res;
}

```

* [[算法之分治思想基础排序]]

##### O(m+n)/O(m*n)

* 当有两个数的时候，**因为无法确认哪个数更大**，所以不能简单地直接省略、使用加法法则，而是只能通过相加的方式 `O(m+n)`. 

```typescript
/**
 * 算法复杂度为 O(m + n) 的场景
 * @param m 
 * @param n 
 * @returns 
 */
function sortTwoArr(m: number[], n: number[]): number {
  let sum: number = 0;

  for (let i = 0; i < m.length; i++) {
    sum += m[i];
  }

  for (let j = 0; j < n.length; j++) {
    sum += n[j];
  }

  return sum;
}
```

* 但是**乘法法则则仍然是适用的。**
* 归纳出公式为：
	* **加法: `T1(m) + T2(n) = O(f(m) + f(n))`.**
	* **乘法: `T1(m) * T2(n) = O(f(m) * f(n))`.**

##### O(n2)

* **平方阶**常见的实际案例就是**冒泡算法**。

```typescript
/**
 * 算法复杂度 O(n2)
 * @param arr 
 * @returns 
 */
function bubbleSort(arr: any[]): any[] {
  let len: number = arr.length;
  for (let i = 0; i < len; i++) {
    for (let j = 0; j < len - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]];
      }
    }
  }

  return arr;
}

bubbleSort([4, 12, 1, 3, 2, 7]);
```

## 空间复杂度分析

* **空间复杂度全称就是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。**
* 观察下面这段代码：

```typescript
function print(n: number) {
  let i = 0;
  let a: number[] = new Array(n);
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    console.log(a[i]);
  }
}
```

* 类似时间复杂度分析，可以看到在第 2 行代码中，申请了一个空间存储变量 `i`。它是常量阶的，和数据规模没有关系，因此可以忽略。
* 第 3 行代码中申请了一个大小为 n 的数组。除此之外，剩下的代码都没有占用更多的空间。因此整段代码的时间复杂度就是 `O(n)`.
* 空间复杂度常见的就是 `O(n)` `O(n2)` `O(1)` 这几种。
* 对数阶复杂度则通常很少用到。例如 `O(logn)`和 `O(nlogn)`。
* *整体来说，空间复杂度的分析会比时间复杂度的分析简单一些。*

### 小结

* 复杂度又称为渐进复杂度，分为时间渐进复杂度和空间渐进复杂度，用来分析算法执行效率与数据规模之间的增长关系。
* 时间复杂度从高阶到低阶分别是：**`O(n^2)` > `O(nlogn)` > `O(n)` > `O(logn)` > `O(1)`**。

![[复杂度增长曲线.png]]

#ALG 