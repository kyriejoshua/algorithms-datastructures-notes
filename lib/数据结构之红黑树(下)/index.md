# 红黑树的实现

## 简言

* 实现红黑树的过程本身确实比较复杂，每个环节都需要缜密的逻辑。这一节的内容可能需要反复回顾才能够彻底理解。在学习的过程中，先尝试理解思路，再渐渐熟练地运用到实践中，最终再能够自己实现红黑树。

> 为什么红黑树的定义中，要求叶子节点必须是黑色的空节点呢？
> 学习曲线：★★★★☆

## 实现红黑树的基本思想

* 红黑树的平衡过程实际上类似于魔方的还原，对于每一种节点排布都有着固定的解法。
* 再来回顾一下红黑树的定义：
	* **根节点是黑色的；**
	* **每个叶子都是黑色的空节点(NIL)，也就是叶子节点不存储数据；**
	* **任何相邻的节点都不能同时为红色，红色节点会被黑色节点分隔开；**
	* **每个节点从该节点到达其可达节点的所有路径，都包含相同数目的黑色节点。**
* 在插入和删除节点的过程中，第三和第四点要求可能会被破坏，今天所讲的“平衡调整”，就是把被破坏的三四点恢复过来。
* 下面先介绍两个重要的操作：**左旋和右旋**。

### 左旋和右旋

* 左旋是围绕某个节点的左旋；
* 右旋是围绕某个节点的右旋。
* 下面的平衡调整会一直用到这两个操作，可以通过观察示意图来帮助理解这两个操作。
	* 图中的 a、b、r 表示子树，可以为空。

![[左旋右旋示意图.png]]

* **左旋的具体操作就是，把右子树的节点变成自己的父节点，当前节点变成右子树的左子树节点，再把原右子树的左子树节点变成自己的右子树节点。**
* **右旋的具体操作就是，把左子树的节点变成自己的父节点，当前节点变成左子树的右子树节点，再把原左子树的右子树节点变成自己的左子树节点。**

#### 左旋右旋的实现

##### 左旋

```typescript
/**
 * @description: 左旋的简略实现
 * @param {TreeNode} node
 * @return {TreeNode}
 */
const rotateLeft = (node: TreeNode): TreeNode => {
  const rightNode = node.right;
  if (rightNode !== null) {
    const leftNode = node.left;
    node.right = leftNode;
    rightNode.left = node;
    // 更新颜色
  }
  return rightNode;
}
```

##### 右旋

```typescript
/**
 * @description: 右旋的简略实现
 * @param {TreeNode} node
 * @return {TreeNode}
 */
const rotateRight = (node: TreeNode): TreeNode => {
  const leftNode = node.left;
  if (leftNode !== null) {
    const rightNode = node.right;
    node.left = rightNode;
    leftNode.right = node;
    // 更新颜色
  }
  return leftNode;
}
```

* 💭 ts 版本的实现优化。

#### 旋转的意义

* 实际上，无论是左旋或是右旋，旋转操作并不会改变这颗红黑树（二叉搜索树）中序遍历的顺序，也就是说，**经过旋转之后的红黑树中序遍历仍然会得到一个有序数组**。
* 而**旋转的目的，其实是为了减小树的高度，从而让红黑树接近平衡。**
* 之前提到，红黑树的插入和删除操作会破坏红黑树的定义，也就是会破坏当前维持的平衡。因此，下面继续深入了解如何调整平衡来继续维持一棵合格的红黑树。

### 插入操作的平衡调整

* 红黑树规定，**插入的节点必须是红色的**。而且，二叉查找树中新插入的节点都是放在叶子节点上。
* 因此插入操作的平衡调整有两种特殊情况，但也比较好处理。
	* **如果插入节点的父节点是黑色的，那不需要额外处理，它仍然满足红黑树的定义。**
	* **如果插入的节点是根节点，那就直接把它改变颜色变成黑色就可以了。**
* 除了这两种情况，其他情况都会违背红黑树的定义，也就是需要我们手动调整，调整的过程包含两种基础操作：**左右旋转和改变颜色。**
* 红黑树的平衡调整过程是一个**迭代的过程**。**通常把正在处理的节点叫作关注节点**。关注节点随着不停地迭代处理而发生变化。**最开始的关注节点就是新插入的节点。**
* **新节点插入之后，如果红黑树的平衡被打破，一般会出现下面三种情况**。 根据每种情况的特点不停调整，就可以让红黑树继续符合定义，也就是继续保持平衡。
* 下面依次来看每种情况的调整过程

#### CASE 1：如果关注节点是 a,它的叔叔节点 d 是红色，就依次执行下面的操作：

* 将关注节点的父节点 b，叔叔节点 d 的颜色设置成黑色；
* 将关注节点 a 的祖父节点 c 的颜色设置成红色；
* 关注节点变成 a 的祖父节点 c;
* 跳转到 CASE 2 或 CASE 3。

![[红黑树插入操作CASE1.png]]

#### CASE 2: 如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的右子节点，就依次执行下面操作：

* 关注节点变成节点 a 的父节点 b;
* 围绕新的关注节点 b 左旋；
* 跳到 CASE3。

![[红黑树插入操作CASE2.png]]

#### CASE 3: 如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点，就依次执行下列操作：

* 围绕关注节点 a 的祖父节点 c 右旋；
* 将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换。
* 调整结束。

![[红黑树插入操作CASE3.png]]

### 删除操作的平衡调整

* 红黑树的删除操作相对插入操作会更复杂，不过万变不离其宗，也是根据各自的场景作出相应的操作即可。
* 删除操作的平衡调整分为两步，第一步是针对删除节点初步调整。
	* 初步调整保证整颗红黑树在一个节点删除之后，仍然满足最后一条定义的要求，也就是每个节点从该节点到达其可达叶子节点的所有路径都包含相同数目的黑色节点。
* 删除操作的第二部是针对关注节点进行二次调整，让它满足红黑树的第三条定义，即不存在相邻的两个红色节点。

#### 1. 针对删除节点的初步调整

* 经过初步调整之后，**为保证红黑树最后一条定义的要求，有些节点会被标记成两种颜色，例如“红-黑”或者“黑-黑”。如果一个节点标记为“黑黑”，则计算黑色节点个数的时候，要算成两个黑色节点。**
* 下图中，*如果一个节点既可以是红色也可以是黑色，就会用一半红色一半黑色来表示。**如果一个节点是“红-黑”或者“黑-黑”，就会用左上角的黑点来表示额外的颜色。** *

##### CASE 1: 如果删除的节点是 a，且只有一个子节点 b，就依次如下操作：

* 删除节点 a，并且把节点 b 替换到 节点 a 的位置，这一部分操作和普通的二叉树删除操作一样；
* 节点 a 只能是黑色，节点 b 也只能是红色，其他情况均不符合红黑树的定义。这时，我们把节点 b 改成黑色；
* 调整结束，不需要二次调整。

![[红黑树删除操作CASE1.png]]

##### CASE 2: 如果删除的节点 a 有两个非空子节点，并且它的后继节点就是节点 a 的右子节点 c，就依次如下操作：
* 如果节点 a 的后继节点就是右子节点 c，那右子节点 c 肯定没有左子树。把节点 a 删除，并且将节点 c 替换到节点 a 的位置。这一步和普通的二叉查找树的操作一致；
* 然后把节点 c 的颜色设置为根节点 a 相同的颜色；
* 如果节点 c 是黑色，为了不违反红黑树的最后一条定义，我们给节点 c 的右子节点 d 多加一个黑色，这时节点 d 就成了 “红-黑”或者“黑-黑”。
* 这时关注节点变成了节点 d，进入第二步的调整操作。

![[红黑树删除操作CASE2.png]]

##### CASE 3: 如果要删除的节点 a 有两个非空子节点，并且节点 a 的后继节点不是右子节点，就依次如下操作：

* 找到后继节点 d，并删除，删除后继节点 d 的过程参照 CASE 1；
* 把节点 a 替换成后继节点 d；
* 把节点 d 的颜色设置为跟节点 a 相同的颜色；
* 如果节点 d 是黑色，为了不违反红黑树的最后一条定义，我们给节点 d 的右子节点 c 多加一个黑色，这时节点 c 变成 “红黑” 或者 “黑黑”；
* 这时，关注节点变成节点 c，进入第二步的调整操作。

![[红黑树删除操作CASE3.png]]

#### 2. 针对关注节点进行二次调整

* 经过初步调整之后，关注节点变成了“红黑”或者“黑黑”节点。针对关注节点需要进行二次调整，*调整的目的是为了不让红黑树中存在相邻的红色节点*。具体可以分成四种情况。

##### CASE 1: 如果关注节点是 a，它的兄弟节点 c 是红色的，依次进行如下操作：

* 围绕关注节点 a 的父节点 b 左旋；
* 关注节点 a 的父节点 b 和祖父节点 c 交换颜色；
* 关注节点不变；
* 继续从四种情况中选择适合的规则来调整。

![[红黑树删除操作2CASE1.png]]

##### CASE 2: 如果关注节点是 a，它的兄弟节点 c 是黑色的，并且节点 c 的左右子节点 d、e 都是黑色的，就依次如下操作：

* 把关注节点 a 的兄弟节点 c 的颜色变成红色；
* 从关注节点 a 中去掉一个黑色，这时节点 a 就是单纯的红色或者黑色；
* 给关注节点 a 的父节点 b 添加一个黑色，这时节点 b 变成了 “红黑”或者“黑黑”；
* 关注节点从 a 节点变成它的父节点 b；
* 继续从四种情况中选择符合的规则来调整。

![[红黑树删除操作2CASE2.png]]

##### CASE 3: 如果关注节点是 a，它的兄弟节点 c 是黑色，c 的左子节点 d 是红色，c 的右子节点 e 是黑色，就依次如下操作：

* 围绕关注节点 a 的兄弟节点 c 右旋；
* 节点 c 和节点 d 交换颜色；
* 关注节点不变；
* 跳转到 CASE 4，继续调整。

![[红黑树删除操作2CASE3.png]]

##### CASE 4: 如果关注节点 a 的兄弟节点 c 是黑色的，并且 c 的右子节点是红色的，就依次如下操作：

* 围绕关注节点 a 的父节点左旋；
* 把关注节点 a 的兄弟节点 c 的颜色，与关注节点 a 的父节点 b 设置成相同的颜色；
* 把关注节点 a 的父节点的颜色设置为黑色；
* 从关注节点 a 中去掉一个黑色，节点 a 就变成了单纯的红色或者黑色；
* 把关注节点 a 的叔叔节点 e 设置为黑色；
* 调整结束。

![[红黑树删除操作2CASE4.png]]

### 为什么红黑树需要黑色的空的叶子节点

* 本质上，要求叶子节点是黑色的空节点这一点，就是为了方便代码实现。因为只要满足这一要求，任何时候红黑树的平衡操作都可以归结为上述的几种情况。
* 下面举例来说明。假设红黑树的定义中不包括这一条：“叶子节点必须是黑色的空节点”。
	* 往一棵红黑树中插入一条数据，根据规律，当前节点是红色的，而如果新插入节点的父节点也是红色的，两个红色的节点相邻，红黑树的定义被破坏了，下面该如何调整呢？

![[红黑树解析黑色空节点示意图1.png]]

* 在这种场景下，前面的插入的三种情况的平衡调整规则都不适用了。
* 但如果把黑色空节点都加上，就会满足 CASE 2。
	* 像下图：

![[红黑树解析黑色空节点示意图2.png]]

* 当然，也可以通过调整规则的方式来让它适用。例如“如果关注节点 a 的叔叔节点 b 是黑色或者不存在，a 是父节点的右子节点，就进行某某操作”。但这样的规则就没有原先的简洁了。
* 可能还会有顾虑，这样给节点添加黑色的空的叶子节点会不会浪费存储空间？答案是并不会。
	* **上图中为方便所以画出了每个黑色空叶子节点，而实际具体实现的时候只需要一个黑色的空的叶子节点拿来共用就可以了**。个人理解为指针指向同一个节点。

![[红黑树解析黑色空节点示意图3.png]]

## 红黑树的视频解析

### B 树

* 其实在学习红黑树之前，可以先粗浅地了解一些 B 树的知识，这样会有助于理解红黑树。

#### B 树的插入创建

<iframe src="https://player.bilibili.com/player.html?bvid=BV1Jh411q7xP&cid=284638929&page=1&share_source=copy_web" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="520px"></iframe>

#### B 树的删除

<iframe src="https://player.bilibili.com/player.html?bvid=BV11h411W74p&cid=284638929&page=1&share_source=copy_web" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="520px"></iframe>

### 左旋和右旋的简单讲解

<iframe src="https://player.bilibili.com/player.html?bvid=BV1aK4y1W7yj&cid=284638929&page=1&share_source=copy_web" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="520px"></iframe>

### 插入操作的简单讲解

<iframe src="https://player.bilibili.com/player.html?bvid=BV1nf4y1z7nP&cid=284638929&page=1&share_source=copy_web" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="520px"></iframe>

### 删除操作的简单讲解

<iframe src="https://player.bilibili.com/player.html?bvid=BV1uZ4y1P7rr&cid=284638929&page=1&share_source=copy_web" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="520px"></iframe>

### 具体的实践案例

* 英文视频，其实是上面几个视频的原版。它是一个完整的系列，下面仅贴上最后一个视频，也就是具体实践的视频，其他视频可以在其中的选集里切换。

<iframe src="https://player.bilibili.com/player.html?bvid=BV17J411P7aJ&p=4&cid=284638929&page=1&share_source=copy_web" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="520px"></iframe>

## 小结

### 红黑树实现的学习思路

* 第一点，**把红黑树的平衡调整过程比作魔方复原而不是过于深究这种算法的正确性。**
* 第二点，**找准关注节点。**
	* 每种操作都是基于关注节点来做的，并且在调整过程中，关注节点会一直在变化，因此找准关注节点也是关键。
* 第三点，**插入的平衡调整操作相对简单，但是删除操作会更加复杂。**
	* 针对删除操作，有两次调整。第一次是针对删除节点做初步调整，让调整后的红黑树继续满足第四条定义，**“每个节点到达可达叶子节点的路径都包含相同个数的黑色节点”**。
	* 第二次调整解决的是 **“不允许存在两个相邻红色节点的情况”** 这个问题。

## 扩展

* 学习红黑树的过程中有何种好的学习方法和体会？可以试着总结。
	* 理解红黑树之前，可以试着先理解 2-3 树。其实红黑树也是基于 [2-3 树](https://www.wikiwand.com/zh-hans/2-3%E6%A0%91)的理念来实现的。[解读文章](https://www.cnblogs.com/tiancai/p/9072813.html)

#ALG #ADT 