# 图

## 简言

* 在许多社交软件里，各个注册用户的关系大多是相连的，微博可以互关，微信可以互加好友。那么这些好友关系是如何存储的呢？
* 其实，这些都是用图这种数据结构来存储的。
* 而且，图设计的算法也有很多，也很复杂，例如*图的搜索、最短路径、最小生成树、二分图等等。*
* 这一节我们主要关注图的概念和图的存储，后续会再继续深入。

> 学习曲线：★★★☆

## 如何理解图(Graph)

* 前面我们学习过树这种非线性表数据结构，这节要讲的图也是另一种非线性表数据结构。
* 在树中，树的元素称之为**节点**。而在图中，图的元素称为**顶点（vertex）**。
	* 图中的任意的顶点可以和其他的顶点建立连接关系，这种**顶点间建立的关系叫做边（edge）**。
	* 下面是图的示意：

![[图的示意.png]]

### 图的实际应用和理解

#### 有向图

* 社交网络就是非常典型的图结构。
	* 以微信为例，每个用户其实就是一个独立的顶点，两个用户间添加好友，那么就是在两者之间建立一条边。
	* 微信的好友关系就可以使用图来表示。其中，每个用户所拥有的好友数量，就是顶点的**度（degree）**，**就是和顶点相连接的边的条数。**
* 而微博的社交关系比微信稍微复杂些，因为微博允许单向关注。用户 A 关注了用户 B，但用户 B 可以不关注用户 A。这就涉及到边的方向的概念，观察下图。

![[有向图的示意.png]]

* 如果用户 A 关注了 B，就画一条从 A 指向 B 的边，这条边带箭头，用来表示边的方向。如果用户 B 也关注了 A，那就也画一条箭头从 B 指向 A 的边。
* **这种边有方向的图称为有向图。同理，上文提到的边没有方向的就是无向图。**
* 上文中我们提到，无向图有度这个概念。在有向图中，因为涉及边的方向，度区分为**入度（In-degree）** 和**出度（Out-degree）**。
	* **顶点的入度，表示有多少边指向当前顶点。**
	* **顶点的出度，表示有多少边是以当前顶点作为起点指向其他顶点。**
	* 对应到微博中，**就是入度表示用户有多少粉丝，出度表示自己关注了多少人。**

#### 带权图

* 在社交软件 QQ 里，有一个亲密度的功能，表示两个用户之间联系紧密的程度。这里就会用到另一种图，**带权图（weighted graph）**。
	* **在带权图中，每条边都会有一个权重（weight）。** 这个权重就可以用来表示 QQ 好友里的亲密度。
	* 如下图所示，每条边的权重以数值展示：

![[带权图的示意.png]]
* 上面就基本介绍完了常用的图的概念。这些概念理解起来并不复杂。下面我们来了解图的存储。

## 图的存储

* 图的存储方式也有很多种，下面介绍邻接矩阵存储法和邻接表存储法两种方式。

### 邻接矩阵存储法

* 图最直观的一种存储方法是**邻接矩阵（Adjacency Matrix）**。
* **邻接矩阵底层依赖一个二维数组。**
	* 对于无向图，如果顶点 i 和顶点 j 之间有边，就把 `A[i][j]` 和 `A[j][i]` 的值设为 1；
	* 对于有向图，如果顶点 i 和顶点 j 之间有一条箭头从 i 指向顶点 j 的边，就把 `A[i][j]` 标记为 1.同理，如果有一条箭头从 j 指向顶点 i 的边，就把 `A[j][i]` 的值设为 1. **可以理解为终点顶点的值设置为 1.**
	* 对于带权图，数组中对应的位置就存储相应的权重而不是 1.

![[邻接矩阵存储示意.png]]

#### 邻接矩阵存储的缺点

* 邻接矩阵表示图的方式简单直观，但却比较占用存储空间。可以理解为**空间换时间**的思想的应用。
* 邻接矩阵比较浪费存储空间的点体现在：
	* 对于无向图，如果 `A[i][j]` 等于 1，那么 `A[j][i]` 实际上也肯定等于 1. 这时其实我们只需要存储一个值就够了。
		* 也就是对于无向图存储的二维数组，如果用对角线把数组划分为上下两部分，那么只需要上面一半的空间或是下面一半的空间就足够，另一半实际是浪费的。
	* 而且如果存储的是**稀疏图（Sparse Matrix）**，顶点很多，但是每个顶点的边不多，那么邻接矩阵存储的方式就会更加浪费空间。
		* 例如微信几亿的用户，但每个用户平均下来可能只有几百个好友，而不需要几亿条边，那么这样的存储空间就会变得十分浪费。

#### 邻接矩阵存储的优点

* 邻接矩阵的优先体现在它存储方式简单直接，而且因为基于数组，获取两个顶点关系的时候会十分高效。
* 其次，邻接矩阵存储的另一个好处是方便计算。这种方式的存储可以将很多图的运算转换成矩阵之间的运算。
	* 比如求解最短路径时会用到的 `Floyd-Warshall` 算法，就是利用矩阵循环相乘若干次得到结果。

### 邻接表存储法

* 针对上一种方法比较浪费存储空间的问题，我们来了解另一种图的存储方法，**邻接表（Adjacency List）**。
* 邻接表的存储方式有些像是散列表。
	* 下面是有向图的邻接表存储方式。**每个顶点对应的链表里，存储的是指向的顶点**。对于无向图也是类似的。

![[邻接表存储示意.png]]
* 邻接表其实是**时间换空间**的思路。它存储起来比较节约空间，但是使用起来就比较耗费时间。
	* 例如图中如果要查找顶点 2 到顶点 4 的边，就需要把顶点 2 对应的链表进行依次遍历，查看是否有顶点 4.
	* 而且之前的章节提到过，链表的存储方式对缓存并不友好。因此比起邻接矩阵的存储方式，邻接表中查询两个顶点之间的关系就显得没有那么高效。
		* 这里我们可以用平衡二叉查找树或者散列表等数据结构来改进链表，也可以使用红黑树或跳表等。

## 如何使用图来存储社交软件的好友关系

* 前面我们分析到，微博是有向图，微信是无向图。两者的解决思路差不多，因为涉及方向，微博相对会更复杂一些。我们以微博为例。
* 首先我们需要确认微博需要哪些操作，以此来确认需要使用何种数据结构与算法。
* 我们期望的基本操作有：
	* *判断用户 A 是否关注 用户 B；*
	* *判断用户 A 是否是 B 的粉丝；*
	* *用户 A 关注用户 B；*
	* *用户 A 取消关注用户 B；*
	* *根据用户名称的首字母排序，分页获取用户的粉丝列表；*
	* *根据用户名称的首字母排序，分页获取用户的关注列表。*
* 社交网络显然是稀疏图，所以适合用邻接表来存储。
	* 使用邻接表可以获取当前用户的关注用户，但是无法获取当前用户的粉丝数量。
	* 因此我们需要一个逆邻接表，每个顶点的链表中，存储的是指向这个顶点的顶点。
		* 如果查找某个用户关注的用户，可以在邻接表中查找；
		* 如果要查找某个用户的粉丝数量，可以在逆邻接表中查找。

![[邻接表和逆邻接表示意.png]]

* 如图所示，基础的邻接表并不能快速地查找用户间是否互相关注。我们需要用改进的版本，也就是换一个数据结构来更快地查找。
	* 因为需要按照用户名的首字母排序，分页来获取用户的粉丝列表或者关注列表，就比较适合用跳表这种数据结构。
	* 跳表的插入、删除、查找的时间复杂度都是 `O(logn)`，都很高效，只是空间复杂度较高，是 `O(n)`。
	* 除此之外，跳表存储的数据本来就是有序的，分页获取粉丝数或关注列表就会十分高效。

### 更庞大用户量的处理

* 在小规模的用户量中，像上文一样处理是可以的，把所有数据都存储在内存中。但如果用户数量在亿级，就无法一次性存储在内存中了。
* **可以使用哈希算法对数据进行分片，把邻接表存储在不同的机器上。**
	* 在不同机器上存储不同的邻接表，然后查询关系的时候，使用同样的哈希算法，先定位顶点所在的机器，再在相应的机器上查找。

![[邻接表数据分片.png]]

* 另一个思路是使用外部存储（硬盘）。数据库是用来持久化存储关系数据的，这里介绍一种数据库的方式。
	* 可以使用下面的表来存储图，在表上使用唯一标识建立多个索引。比如给下面的第一列和第二列建立索引。

![[数据库建立索引存储图.png]]

## 小结

* 这节主要是理解非线性表数据结构，图。这些概念需要十分熟悉：
	* 有向图；
	* 无向图；
	* 顶点；
	* 边；
	* 度；
	* 出度、入度；
	* 带权图。
* 这节还了解图的两种主要存储方式：邻接矩阵和邻接表。
	* 邻接矩阵的缺点是比较浪费空间，优点是查询效率高，而且方便矩阵运算。
	* 邻接表存储方法中每个顶点都对应一个链表，存储与其连接的其他顶点。邻接表的存储方式比较节省存储空间，但链表不方便查找，查询效率不如邻接矩阵的方式高。
		* 针对这个问题，邻接表可以把链表升级成平衡二叉查找树、跳表或散列表等。

## 扩展

* 例如微信这类无向图是如何存储的？
	* 使用邻接表，且每个顶点的度的值等于对应每条链表的结点数量。💭
* 关于图这种数据结构，除了知识图谱（knowkedge graph）现实中还有哪些例子？
	* 计算机网络。

#ALG #ADT 