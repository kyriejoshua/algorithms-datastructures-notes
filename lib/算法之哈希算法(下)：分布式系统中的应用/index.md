# 哈希算法的分布式应用场景

## 简言

* 上一节的内容分析了哈希算法的四种应用场景，而剩余的几种应用场景都和分布式系统相关。
* 这一节介绍的这三种应用都可以解决分布式问题。

> 学习曲线：★★☆

## 负载均衡

* 负载均衡的常规算法有轮询，随机，加权轮询等。

### 负载均衡的会话粘滞算法

* 一般情况下，如何实现负载均衡的会话粘滞（session sticky）的算法呢？
	* 会话粘滞是指，**在同一个客户端上，在一次会话中的所有请求都会路由到同一个服务器上**。 
* 比较直接的解决方式是维护一张映射表，里面是客户端 IP 地址或会话 ID 与服务器编号的映射关系。这样客户端发出的每一个请求，都会先通过 IP 地址或会话 ID，在映射表中找到服务器的编号，从而再请求对应的服务器。这种方法简单直接，但也有以下问题：
	* 如果客户端很多，映射表会很大，浪费内存空间。
	* 客户端下线，上线，服务器扩容、缩容都会导致映射失效，映射表的维护成本就会很大。

#### 解决思路

* 使用哈希算法的解决方案：对客户端 IP 或者会话 ID 计算哈希值，然后把取得的哈希值和服务器列表的大小进行**取模运算**，得到的结果就是服务器的编号。
* 这样的方式能够保证同一个 IP 的所有请求都会路由到同一个后端服务器上。

## 数据分片

### 1. 统计搜索关键词出现的次数

* 假设有 1 T 的搜索日志文件，记录了用户搜索的关键词。
* 这里统计关键词次数的难点在于：
	* 所有记录放在一台机器上，内存空间不够；
	* 而且仅在一台机器上处理如此巨大的数据，处理事件会很长，响应时间会很慢。
* 针对这两个问题，可以采用先对数据进行分片，再使用多台机器处理的方式，来提高处理速度。

#### 解决思路

* 使用 n 台机器并行处理，从搜索日志中依次读取关键词，通过哈希函数计算出哈希值，再跟 n 取模，得到的值就是分配到的机器编号。
* 哈希值相同的搜索关键词会分配到同一台机器上，也就是同一个搜索关键词会分配到同一台机器上，每个机器会分别计算关键词出现的次数，并最终汇总得到结果。
* 这里的处理过程实际也是 `MapReduce` 的基本设计思想。
	*  而 [`MapReduce`](https://www.wikiwand.com/zh-hans/MapReduce) 是由谷歌提出的架构。

### 2. 如何快速判断图片是否在图库中

* 假设现在图库中有 1 亿张图片，这在单台机器上构建散列表显然是不行的，因为单台机器的内存有限，而 1 亿张图片的索引构建散列表明显远远超过了单台机器的内存上限。
* 但这里同样可以对数据进行分片，然后采用多机器处理。我们准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。每次从图库中读取一张图片，计算唯一标识，然后与机器个数 n 取模，得到的值就对应要分配的机器编号，然后将这张图片的唯一标识和图片路径发往对应的机器构建散列表。
* 当我们判断一张图片是否在图库中的时候，通过同样的哈希算法，计算这张图片的唯一标识，然后与机器个数 n 求余取模。假设得到的值是 k，就去编号为 k 的机器构建的散列表中查找。

#### 估算 1 亿张图片的散列表所需的机器数量

* 一般情况下，散列表中的每个数据单元包含两个信息：**图片的唯一标识哈希值**和**图片路径**。
	* 通过 MD5 转换后的哈希值是 128 bit，也就是 16 字节。
	* 而文件路径的长度的上限是 256 字节，这里可以取预估的平均值 128 字节。
	* 而如果用链表法来解决冲突，链表的指针所需的内存空间是 8 字节。
	* 那么一张图片所需的空间就是 `16+128+8=152` 字节。
* 假设一台机器的内存大小是 2G，散列表的装载因子是 0.75，那么每台机器可以存储 `2000 * 1000 * 1000 * 0.75 / 152` 得到近千万的结果，也就是可以存储近一千万张图片。
* 所以，对 1 亿张图片建立索引，所需的机器数量大约就是十几台。
* *这种预估能帮助我们事先确认大概的投入资源和资金，以便更好地评估方案的可行性。*
* 而针对此类海量数据，都可以采用多机器分布式处理。**借助这种分布式处理思路，可以突破单机内存，CPU 等资源的限制。**

## 分布式存储

* 现在互联网面对的都是海量的数据和海量的用户。为了提高数据的读取和写入能力，一般都采用分布式的方式来存储数据，比如分布式缓存。
* 把海量的数据分布在多台机器进行缓存处理。
* 该如何决定把哪个数据放到哪台机器上呢？
	* 这里可以借用前面数据分片的思想，即通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号。
* 但是如果机器增多，也就是机器扩容，就会出现问题。
	* 因为之前计算都是哈希值对 n 个机器取模的结果，现在机器数量变成 n + 1，取模的结果全部都会发生变化。因此，所有的数据都需要重新计算哈希值，然后重新搬移到正确的机器上。
	* 这样就相当于所有缓存都失效。所有请求都会穿透缓存，直接去请求数据库，这样就可能压垮数据库。
	* 如下图，对 10 取模之后改成对 11 取模，结果就会完全不同，导致所有缓存失效。

![[分布式机器扩容示意.png]]

* 所以需要一种解决方案，**能够保证在加入一个新机器后，所进行的数据搬移的成本是最小的。这就是一致性哈希算法。**

### 一致性哈希算法

* 假设有 k 个机器，数据的哈希值范围是 `[0, MAX]`. 将整个范围划分成 m 个小区间，同时 m 远大于 k，每个机器负责 `m / k` 个小区间。
* 当有新机器加入的时候，就只需要把个别小区间的数据，从原来的机器中搬移到新机器。
	* 按照机器的负载范围来划分，而不是取模。例如 `m = 10000`, `k = 10`, 每个机器负责 1000 范围的区间。当 k 变成 11，每个机器负责的内容变成 `10000 / 11`, 所需要的改动相对是较小的。不知这样理解是否正确。💭
* 这样既不用全部重新哈希，搬移数据，也保持了各个机器上数据数量的均衡。
* 一致性哈希算法的基本思想就是这么简单。除此之外，它还会借助一个虚拟的环和虚拟结点，更加优雅地实现出来。这里先暂不展开。
* 实际上，一致性哈希算法在很多分布式存储系统中都有着广泛的应用。

## 小结

* 这一节主要关注哈希算法在分布式系统中的应用：负载均衡，数据分片，分布式存储。
* 在负载均衡应用中，利用哈希算法替代映射表，可以实现一个会话粘滞的负载均衡策略。
* 在数据分片应用中，通过哈希算法对处理的海量数据进行分片，多机器分布式处理，可以突破单机资源的限制。
* 在分布式存储应用中，利用一致性哈希算法，可以解决缓存等分布式系统扩容、缩容导致数据大量搬移的难题。
* *而这些应用的处理方式核心就是对哈希算法计算后的哈希值取模运算。*

## 扩展

* 这两节主要关注哈希算法的七类应用。实际开发中，还有哪些常见的应用呢？
	* git commit id 是非常常见的应用。
	* 区块链，比特币等虚拟货币。
	* 其他 💭

#ALG
