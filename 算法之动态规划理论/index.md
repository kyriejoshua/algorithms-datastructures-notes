# 动态规划的理论

## 简言

* 在这一章节，我们主要解决以下这几个问题：
	* *什么样的问题可以用动态规划解决？*
	* *解决动态规划的一般思考过程是怎样的？*
	* *贪心、分治、回溯、动态规划这几种算法思想有什么区别和联系？*

> 学习曲线：★★★★

## “一个模型三个特征”理论

* 这是原章节作者自己总结的理论，是对前人智慧的沉淀。

### 一个模型

* 一个模型指的是动态规划适合解决问题的模型。原文作者把它定义为**“多阶段决策最优解模型”**。
* 动态规划类的问题一般用来解决最优问题，解决问题的过程中需要经历多个决策阶段，每个决策节点都对应着一组状态，我们寻找一组决策序列，能够产生最终期望求解的最优值。
* 下面来看三个特征，它们分别是：**最优子结构、无后效性和重复子问题**。

### 1. 最优子结构

* **最优子结构指的是，问题的最优解包含子问题的最优解。也可以反过来，通过子问题的最优解，推导出问题的最优解。**
* 我们把这个理论应用到动态规划里，就是**后面阶段的状态可以通过前面阶段的状态推导出来。**

### 2. 无后效性

* 无后效性理解起来有两层含义。
	* 第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，而不关心这个状态如何一步步推导出来的；
	* 第二层含义就是，某个阶段的状态一旦确定，就不受之后阶段的决策影响。
* 这个要求相对比较宽松，只要满足前面提到的模型要求，就会满足这个条件。

### 3. 重复子问题

* **重复子问题可以理解为，不同的决策序列在到达某个相同的阶段的时候，可能会产生重复的状态。**
	* 这个重复的状态可以理解为动态规划比不使用缓存的回溯算法高效的关键。

## “一个模型三个特征”实例分析（最小路径和）

* 我们通过一个实际案例来结合上面的理论进行分析。

### 求最小路径和题干

* 假设有一个 n 乘以 n 的矩阵 `w[n][n]`. 矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。我们把棋子从左上角移动到右下角。规定每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。我们把每条路径经过的数字加起来看作路径的长度。那么从左上角移动到右下角的最短路径长度是多少呢？


![[最小路径和示意图.png]]

### 最小路径和问题是否符合一个模型和三个特征

#### 最小路径和符合一个模型

* 我们先确认这个问题是否符合一个模型。
* 从 `(0, 0)` 走到  `(n - 1, n - 1)`, 总共要走 `2 * (n - 1)` 个阶段。每个阶段都有向右走或者向下走两种决策，并且每个阶段都会对应一个状态集合。
* 我们把状态定义为 `min_dist(i, j)`, 其中 i 表示行，j 表示列。`min_dist` 表达式的值表示从 `(0, 0)` 到达 `(i, j)` 的最短路径长度。
	* 这个问题就是一个多阶段最优解问题，符合动态规划的模型。

![[最小路径和的一个模型.png]]

#### 最小路径和符合三个特征

* 接下来我们验证这个问题是否符合三个特征。
* 我们可以用回溯算法来解决这个问题，并且画出递归树。由递归树可以发现，里面有很多重复的节点。而重复的节点表示从左上角到节点对应的位置，有多种路线，说明这个问题存在子问题。

![[最小路径和存在子问题.png]]

* 当我们走到 `(i, j)` 这个位置时，只能通过 `(i - 1,j)` 和 `(i, j - 1)` 这两个位置移动过来。因此，想要知道 `(i, j)` 位置对应的状态，只需要关心 `(i - 1, j)` 和 `(i, j - 1)` 两个位置所对应的状态，而不用关心棋子是通过什么路线（*中间过程*）到达这两个位置的。
* 而且，条件仅运行棋子往下和往右移动，不允许后退和其他走路方式。那么前面的状态确认之后，不会被后面阶段的决策所改变。因此，由上述两点可以确认这个问符合“无后效性”这个特征。
* 上文中分析模型的时候，**我们把从起始位置 `(0, 0)` 到 `(i, j)` 的最小路径，记作 `min_dist(i, j)`。因为题目限定了移动规则，最后一个点就只可能从 `(i - 1, j)` 或 `(i, j - 1)` 移动过来。到达 `(i, j)` 的最短路径要么经过  `(i - 1, j)` 或者 `(i, j - 1)` ，而且到达  `(i, j)`  的最短路径肯定也包含到达前面两者的最短路径之一。**
	* `min_dist(i, j)` 可以通过 `min_dist(i - 1, j)` 和  `min_dist(i, j-1)` 两个状态推导出来。
	* 说明这个问题符合最优子结构。
* 下面是递推公式。

```typescript
min_dist(i, j) = w[i][j] + Math.min(min_dist(i - 1, j), min_dist(i, j - 1));
```

### 最小路径和的题目

* 这道题对应 **[LeetCode-64](https://leetcode-cn.com/problems/minimum-path-sum): 最小路径和**，题解在下文里通过两种方式分别详细列出。

## 两种动态规划解题思路总结

* 解决动态规划类的问题，一般有两种思路。可以分别称作**状态转移表法**和**状态转移方程法**。

### 状态转移表法

* 通常可以使用动态规划解决的问题，一般也都可以使用回溯算法的暴力搜索解决。因此可以先尝试使用回溯算法解决，然后定义状态，每个状态对应一个节点，然后画出对应的递归树。从递归树里可以确认是否存在重复的子问题，以及重复子问题是如何产生的。
* 找到重复子问题之后，有两种处理思路来解决。
	* 第一种是回溯算法加备忘录的方式，来避免重复子问题。从执行效率上看，这和动态规划的解决思路没有差别。
	* 第二种是用动态规划的状态转移表法。
* **使用状态转移表法，我们画出一个状态表，通常状态表都是二维的，所以可以当成是二维数组。每个状态包含三个变量，行、列、数组值。我们根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后把这个递推填表的过程，翻译成代码，就是动态规划的实现。**
* 尽管大部分情况下状态表都是二维的，但是如果问题实在比较复杂，需要很多变量来标识，那么对应的状态表有可能是高维的，例如三维、四维。这时就不适合用状态转移表法来解决。一是高维状态难以抽象成图表标识，二是我们也不擅长思考高维的事物。
* 现在我们通过状态转移表法来解决上文的矩阵最短路径的问题。
	* 从起点到终点，穷举所有走法，对比找出一个最短走法。可以先用回溯算法来实现。

```java
private int minDist = Integer.MAX_VALUE; // 全局变量或者成员变量
// 调用方式：minDistBacktracing(0, 0, 0, w, n);
public void minDistBT(int i, int j, int dist, int[][] w, int n) {
  // 到达了n-1, n-1这个位置了，这里看着有点奇怪哈，你自己举个例子看下
  if (i == n && j == n) {
    if (dist < minDist) minDist = dist;
    return;
  }
  if (i < n) { // 往下走，更新i=i+1, j=j
    minDistBT(i + 1, j, dist+w[i][j], w, n);
  }
  if (j < n) { // 往右走，更新i=i, j=j+1
    minDistBT(i, j+1, dist+w[i][j], w, n);
  }
}
```

* 通过回溯算法，我们画出递归树来寻找重复子问题。在递归树里，一个状态（一个节点）包含三个变量 `(i, j, dist)`, 其中 i 和 j 分别表示行和列，`dist` 表示从起点到达 `(i, j)` 的路径长度。
	* 从下图可以看出，虽然 `(i, j, dist)` 不存在重复的，但是 `(i, j)` 重复的有很多，对于 `(i, j)` 重复的节点，我们只需要选择 `dist` 最小的节点继续递归求解，其他节点就可以直接舍弃。

![[最小路径和递归树.png]]

* *存在重复子问题，就可以尝试使用动态规划来求解。*
* 我们画出一个二维状态表，表中的行、列表示棋子所在的位置，表中的数值表示从起点到这个位置的最短路径。我们按照决策过程，通过不断状态递推演进，把状态表填写完整。
	* 为了方便代码实现，我们按行来依次填充。

![[最小路径和状态转移表法1.png]]
![[最小路径和状态转移表法2.png]]

* 把填表的过程翻译成代码，就是下面这样。

```java
public int minDistDP(int[][] matrix, int n) {
  int[][] states = new int[n][n];
  int sum = 0;
  for (int j = 0; j < n; ++j) { // 初始化states的第一行数据
    sum += matrix[0][j];
    states[0][j] = sum;
  }
  sum = 0;
  for (int i = 0; i < n; ++i) { // 初始化states的第一列数据
    sum += matrix[i][0];
    states[i][0] = sum;
  }
  for (int i = 1; i < n; ++i) {
    for (int j = 1; j < n; ++j) {
      states[i][j] = 
            matrix[i][j] + Math.min(states[i][j-1], states[i-1][j]);
    }
  }
  return states[n-1][n-1];
}
```

#### 状态转移表法 TS 实现

* 对应上文提到的 LeetCode 的题解。

```typescript
/**
 * @description: 状态转移表法
 * 先画出填表的过程，再把填表的过程翻译成代码
 * @param {number[][]} grid
 * @return {number}
 */
function minPathSum(grid: number[][]): number {
  const m = grid.length; // 行的长度
  const n = grid[0].length; // 列的长度
  const dp = new Array(m + 1).fill(null).map(() => (new Array(n + 1)).fill(0)); // 初始化 dp 数组
   // 获取 dp 数组初始值，始终从左上角开始，第一个值就是左上角格子的值
  dp[0][0] = grid[0][0];

  let rowSum = 0;
  let colSum = 0;
  // !初始化行和列，得到第一行的值和第一列的值，用来向后推断
  // 注意这里遍历值的极限情况，对应的是内部数组的长度
  for(let i = 0; i < n; i++) {
    rowSum += grid[0][i];
    dp[0][i] = rowSum;
  }

  for (let j = 0; j < m; j++) {
    colSum += grid[j][0];
    dp[j][0] = colSum;
  }

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n;j++) {
      // 把当前路径的值加上前面路径最小的作为值
      dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
    }  
  }

  // 最后终点保存的值就是最小值
  return dp[m - 1][n - 1];
};
```

### 状态转移方程法

* 状态转移方程法有些类似于递归的解题思路。递归的关键在于求出递推公式。某个问题如何通过子问题来递归求解，也就是所谓的最优子结构，可以根据最优子结构写出递推公式。而状态转移方程法的关键在于求出状态转移方程。这个方程其实就对应着递推公式。
* 通常有两种方式来实现代码，一是递归加备忘录，另一种是迭代递推。
* 下面其实就是状态转移方程，上文中已经用 TS 表示过，这里是原文的伪代码再展示一遍。

```java
min_dist(i, j) = w[i][j] + min(min_dist(i, j - 1), min_dist(i - 1, j))
```

* **状态转移方程实际上是解决动态规划类问题的关键。** 如果写出状态转移方程，实际上动态规划问题就已经解决了一大半。
* 下面是递归加备忘录的方式，把状态转移方程翻译成代码。这个的实现方式和状态转移表法的实现是一样的，只是思路不同。

```java
private int[][] matrix = {{1，3，5，9}, {2，1，3，4}，{5，2，6，7}，{6，8，4，3}};
private int n = 4;
private int[][] mem = new int[4][4];
public int minDist(int i, int j) { // 调用minDist(n-1, n-1);
  if (i == 0 && j == 0) return matrix[0][0];
  if (mem[i][j] > 0) return mem[i][j];
  int minLeft = Integer.MAX_VALUE;
  if (j-1 >= 0) {
    minLeft = minDist(i, j-1);
  }
  int minUp = Integer.MAX_VALUE;
  if (i-1 >= 0) {
    minUp = minDist(i-1, j);
  }
  
  int currMinDist = matrix[i][j] + Math.min(minLeft, minUp);
  mem[i][j] = currMinDist;
  return currMinDist;
}
```

#### 状态转移方程法 TS 实现

* 这个实现有点类似于回溯算法加上缓存。

```typescript
/**
 * @description: 状态转移方程法
 * @param {number[][]} grid
 * @return {number}
 */
function minPathSum(grid: number[][]): number {
  const m = grid.length; // 列的长度
  const n = grid[0].length; // 行的长度
  const dp = new Array(m + 1).fill(null).map(() => (new Array(n + 1)).fill(0)); // 初始化 dp 数组

	/**
   * @description: 递归计算
   * @param {number} row
   * @param {number} col
   * @return {number}
   */
  function minDist(row: number, col: number): number {
    if (row === 0 && col === 0) return grid[0][0];
    if (dp[row][col]) return dp[row][col];
    
    let minUp = Number.MAX_SAFE_INTEGER;
    let minLeft = Number.MAX_SAFE_INTEGER;

    if (row > 0) {
      minUp = minDist(row - 1, col);
    }

    if (col > 0) {
      minLeft = minDist(row, col - 1);
    }
    // 保存当前值的最小值
    dp[row][col] = grid[row][col] + Math.min(minUp, minLeft);
    return dp[row][col];
  }

  // 传入参数让其递归计算
  return minDist(m - 1, n - 1);
}
```

* 动态规划的解题理论就是以上这些。实际应用场景中，不是每个问题都同时适合这两种解题思路。有时候适合第一种，有时候第二种分析起来思路更加清晰，需要具体场景具体分析。

## 动态规划视频解析

* 这个视频主要从该 up 主自身的角度，总结一套适用于动态规划的方法论并分享出来。

<iframe src='https://player.bilibili.com/player.html?bvid=BV13Q4y197Wg&cid=480842293&page=1&share_source=copy_web' scrolling='no' border='0' frameborder='no' framespacing='0' allowfullscreen='true' height="520" width="100%"></iframe>

### 动态规划解题方法论

* 理解 dp 数组及其下标的含义。
	* `dp[i][j]` 表示从 0 到 i 位所构成的值在 j 位所表示的值。在基础的 0-1 背包中，它表示取到 i 个物品时，重量在 j 范围内的当前重量值。
* 递推公式。
* DP 数组初始化的值。
	* 大部分的数组在初始化时得到的值是自然而然的，但有些时候也需要思考来进行初始化。
* DP 数组的遍历顺序。
	* 遍历二维数组的过程中，理解这两个 for 循环的先后顺序也是有意义的，能够帮助我们更深入的理解解题思路过程。
* 打印 DP 数组。
	* 可以用来调试发现错误。

## 四种算法思想比较

* 对这四种算法思想硬要分类的话，贪心、回溯、动态规划可以归为一类，分治单独归为一类。因为前三者算法解决的模型，都可以抽象成这节所提到的 *多阶段决策最优解模型*，而分治算法解决的问题并不完全都能抽象成多阶段决策模型。
* 回溯算法是比较通用的，基本上能使用动态规划或是贪心算法解决的问题，本质上都可以通过回溯算法来解决。回溯算法相当于穷举搜索，穷举所有情况，然后对比得到最优解。但是回溯算法的时间复杂度也非常高，是指数级别的，只能用于解决小规模数据的问题。对于大规模数据的问题，用回溯算法来解决就会效率很低。
* 动态规划显然比回溯算法高效，但它的适用场景也比较局限，需要满足三个特征，最优子结构、无后效性和重复子问题。在重复子问题这点上，动态规划和分治算法的区分非常明显。
	* 分治算法要求分割成的子问题，不能有重复子问题；
	* 而动态规划正好相反，它之所以高效，就是因为回溯算法中存在大量的重复子问题，而在动态规划中得到了优化。
* 贪心算法实际上是动态规划算法的一种特殊情况。它解决问题更加高效，代码也更加简洁。当然，它所应用的场景也更加有限。
	* 贪心算法解决的问题需要满足三大条件，最优子结构、无后效性和贪心选择性。
	* 贪心选择性的意思是通过局部最优的选择，进而产生全局的最优选择，每个阶段都决策选出当前最好的方案，所有阶段的决策完成之后，这些局部最优解构成了全局最优解。

## 小结

* 这节总结了什么样的问题适合用动态规划算法来解决。这类问题可以概括为”一个模型三个特征“，”一个模型“是指问题可以抽象成多阶段决策最优解模型。”三个特征“指的是最优子结构、无后效性和重复子问题。
* 有两种动态规划的解题思路，分别是状态转移表法和状态转移方程法。
	* 状态转移表法可以概括成：**回溯算法实现-定义状态-画递归树-找重复子问题-画状态转移表-根据递推关系填表-把填表过程翻译成代码。**
	* 状态转移方程法的核心思路：**找到最优子结构-写出状态转移方程-把状态转移方程翻译成代码。**
* 我们对比了四种算法思想，贪心、回溯、动态规划这三者类似，都可以抽象成多阶段决策最优解模型，而分治独自一类。
* 对于动态规划的理解，很重要的一点是独立思考并实践。可以通过不断的解决这类问题来积累解题思路的经验。后面的一节仍然是关于动态规划的，可以在后续的章节学完之后，再回过来理解这一节的理论。

## 扩展

* *假设有多种不同币值的硬币 v1，v2，......, vn（单位是元）。如果要支付 w 元，求最少需要多少个硬币。例如，有三种不同的额硬币，1 元，3元，5元，需要支付 9 元时，最少需要三个硬币（3 个 3元的硬币）。*

#ALG 