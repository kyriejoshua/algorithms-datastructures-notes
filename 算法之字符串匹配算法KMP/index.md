# KMP 算法

## 引言

* 在通常的学习路线规划中，会优先学习 KMP 算法，再学习 BM 算法。这样的学习曲线会是由浅入深，由相对简单到愈加复杂。而且，KMP 算法的知名度也似乎更高。但这里不知为何作者是先介绍 BM 算法，于是自己也跟着这一节奏学习下来。也许完全理解 BM 算法后，再来理解 KMP 也是不错的思路。
* 这一章节就来学习字符串匹配算法中更加知名的 KMP 算法。

> 学习曲线：★★★★


## KMP 算法的核心思路

* KMP 算法的比较也是遵循我们的常规思路的，即从前往后一位一位字符进行比较。**在主串 a 中比较到不同字符的时候，记录下模式串 b 中当前字符前面的最大公共前缀后缀字符串，记录它的长度，作为向后移动的位数。如果没有公共前缀后缀字符串，就移动 1 位。**
	* 具体而言，例如 `ABABAECB`, 在比较到第 5 位也就是 E 的时候，从该位以前的子串里寻找公共前缀后缀子串，此时的前缀子串为 `ABAB`, 后缀子串为 `BABA`. 那么他们的最大公共子串就是 `ABA`，将这两个子串的前后的下标位置相减，就得到了本次移动的位数。
* 以上就是个人对于 KMP 算法核心思路的理解。下面我们来看看原文章节里是如何一步一步理解整个 KMP 算法过程的。

### KMP 基本原理

* KMP 算法全称 `Knuth Morris Pratt`, 是由三位作者的名字来命名的。
* 可以类比 BM 算法来理解 KMP 算法的比较思路，我们仍然把模式串中已经匹配的字符串叫作**好前缀**，把不能匹配的字符叫作**坏字符**。如下所示：

![[KMP中的好前缀和坏字符.png]]

* 当比较遇到坏字符的时候，我们要把模式串向后移动，移动过程中，只要模式串和好前缀上下重合，前面几个字符的比较就可以类比为**好前缀的后缀子串**和**模式串的前缀子串**在比较。其实也可以看作是**模式串自身的前缀子串和后缀子串在比较**。

![[KMP好前缀的后缀子串与模式串的前缀子串.png]]

* 当我们找到匹配的公共子串时，其实可以据此寻找出一种规律，根据这种规律来更快速地向后移动，提高比较效率。
* 也就是**寻找好前缀后缀子串和模式串的前缀子串的最大公共子串**，假设这段最大公共可匹配的子串是 `{v}`, 长度是 k。那么把模式串向后移动 `j - k` 位，相当于每次更新后比较的下标位数来到 `j = j - k` 位，然后继续比较。

![[移动最长公共子串的长度.png]]

* 这里为了更好的理解上文所提到的两个比较的子串；我们简单的定义，**把好前缀的所有后缀子串中，最长的可匹配的后缀子串，称为最长可匹配后缀子串；对应的前缀子串，称为最长可匹配前缀子串。**

![[最长可匹配后缀子串与最长可匹配前缀子串.png]]

* 观察上图可以发现，其实**在模式串中某一位的好前缀中查找最长可匹配的公共子串，是不涉及主串的**。在不同的主串中，任何的字符都可能成为好字符。因此我们甚至可以在比较前，就计算好每一位子串的最长可匹配公共子串进行存储，这样在比较的时候就可以直接根据计算好的值进行移动。
* 这个计算就类似 BM 算法中的 `bc`、`suffix`、`prefix` 数组，KMP 算法也可以构建一个类似数组，用于存储模式串中每个前缀的最长可匹配前缀子串的结尾字符下标。我们把这个数组定义为 `next` 数组。有些书籍中给这个数组起了名字，叫作失效函数(`failure function`).
* `next` 数组的下标是每个前缀子串的结尾字符的下标，数组的值是这个前缀子串所对应的最长公共前缀子串的结尾的下标。具体可以观察下图来理解。

![[next数组存储公共子串示意图.png]]

* 这里第一列是当前不匹配字符（坏字符）的模式串前缀。下表是自己整理的更加全的表格，最后两列移动位数待验证，理论上对应着 `next[k - 1]` 的值。

| 模式串前缀<br/>(好前缀候选) | 前缀结尾字符下标 | 最长可匹配前缀子串<br/>结尾字符下标 | next值     | 对应公共子串 | 移动位数    |  移动后<br/>比较的下标   |
| --------------------------- | ---------------- | ----------------------------------- | ---------- | -------------- | ------------------- | --- |
| a                           | 0                | -1(表示不存在)                      | next[0]=-1 | 无             | 首位无需移动        | 1   |
| ab                          | 1                | -1                                  | next[1]=-1 | 无             | 1(-1意味着移动一位) | 1    |
| aba                         | 2                | 0                                   | next[2]=0  | a              | 2 - 0 = 2           | 1    |
| abab                        | 3                | 1                                   | next[3]=1  | ab             | 3 - 1 = 2           |  2   |
| ababa                       | 4                | 2                                   | next[4]=2  | aba            | 4 - 2 = 2           |  3   |
| ababac                      | 5                | -1                                  | next[5]=-1 | 无             | 1                    |  4  |

* 也可以用另一种形式来表示，等同于最后一列的效果，称为**前缀表**。计算方式和上面的表格不同，也就是代码实现略有不同，但本质上原理是一致的。下面前缀表的值可以直接取值来定位需要跳到的下标位置，也就是对应 `next[k]` 的值。

| 模式串前缀<br/>(好前缀候选) | 前缀结尾字符下标 | 前缀表 | 
| --------------------------- | ---------------- | ------------------------ |
| a                           | 0                | -1(表示不存在)                      |
| ab                          | 1                | 0                               |
| aba                         | 2                | 0                              |
| abab                        | 3                | 1                             |
| ababa                       | 4                | 2                             |
| ababac                      | 5                | 3                            |

* 其中，**移动后重新进行比较的首位下标位数，就是最长公共子串的长度加 1。**

## KMP 算法实现

* 有了上述 `next` 数组，我们就可以来实现 KMP 算法。这里先假设 `next` 数组已经实现，下面是 KMP 算法的 Java 实现的框架。
	* **在遇到匹配的字符时标记已匹配的字符长度，在遇到不匹配的字符时根据失效函数(`next`数组)回退到之前的位置。**

```java
// a, b分别是主串和模式串；n, m分别是主串和模式串的长度。
public static int kmp(char[] a, int n, char[] b, int m) {
  int[] next = getNexts(b, m);
  int j = 0;
  for (int i = 0; i < n; ++i) {
    while (j > 0 && a[i] != b[j]) { // 一直找到a[i]和b[j]
      j = next[j - 1] + 1;
    }
    if (a[i] == b[j]) {
      ++j;
    }
    if (j == m) { // 找到匹配模式串的了
      return i - m + 1;
    }
  }
  return -1;
}
```

### 失效函数计算方法

* `next` 数组的计算其实就是 KMP 算法最复杂的部分。
* 我们可以用暴力匹配的方式，找出模式串某个好前缀子串的所有后缀子串，再从长到短一个个比较字符串。但显然这种方法不够高效。

![[低效计算next数组示意图.png]]

* 这里的计算思路其实类似于**动态规划**，但这一节还没有聊到。我们换种思路来理解。
* 当我们按下标从小到大依次计算 `next` 数组的值的时候，如果正在计算 `next[i]`，那么实际上 `next[i-1]`、`next[i-2]`... `next[1]` 和 `next[0]` 的值已经计算得到了。接着的思路就可以理解为，**如何利用已经求得的值，来快速推导出 `next[i]` 的值。**
* 如果 `next[i - 1] = k - 1`，那么子串 `b[0, k - 1]` 就是 `b[0, i - 1]` 的最长可匹配前缀子串。如果子串 `b[0, k - 1]` 的下一个子符 `b[k]`, 和 `b[0, i - 1]` 的下一个字符 `b[i]` 匹配，那么子串 `b[0, k]` 就是 `b[0, i]` 的最长可匹配前缀子串。这时，`next[i] = k`. 而如果 `b[0, k - 1]` 的下一个字符 `b[k]` 和 `b[0, i - 1]` 的下一个字符 `b[i]` 不匹配，就需要再次计算。
	* **如果前一位字符的最长公共前缀子串的下一位和当前字符相等，那么前一位的最长公共前缀加上字符 `b[k]` 就是当前字符的最长公共字符。**
		* 假设有模式串 b 为 `ababa`, 先求最后一位的前一位字符 b 的最长公共前缀，也就是 `abab` 的最长公共前缀子串是 `ab`. 它的下一位是 a，这里的 a 与当前最后一位字符 a 相等。那么 `ababa` 的最长公共前缀子串就是 `aba`. 
		* 其中，`b[0, i]` 对应 `ababa`, `b[0, i - 1]` 对应 `abab`. `next[i - 1]` 就是 2, 而 `next[i] = 3`. 其中 `b[0, k - 1]` 是 `ab`, `b[0, k]` 是 `aba`.
	* 而不相等的情况，我们接着往下看。

![[计算next数组示意图1.png]]

* 假设 `b[0, i]` 的**最长可匹配后缀子串**是 `b[r, i]`. 这时我们把最后一个字符去掉，那么 `b[r, i - 1] ` 肯定是 `b[r, i - 1]` 的**可匹配后缀子串**，但不一定是最长可匹配后缀子串。而且当前的情况是，`b[0, i - 1]` 的最长可匹配后缀子串对应的可匹配前缀子串的下一个字符并不等于 `b[i]`. 我们可以观察 `b[i - 1]` 的**次长可匹配后缀子串** b[x, i - 1] 对应的**可匹配前缀子串 `b[0, i - 1 - x]`** 的下一个字符 `b[i - x]` 是否等于 `b[i]`. 如果等于，那么 `b[0, i - x]` 就是 `b[0, i]` 的最长可匹配前缀子串，`b[x, i]` 就是 `b[0, i]` 的最长可匹配后缀子串。

![[计算next数组示意图2.png]]

* 求解 `b[0, i - 1]` 的次长可匹配后缀子串，可以先求解最长可匹配后缀子串，而最长可匹配后缀子串，又一定被包含在最长可匹配前缀子串 `b[0, y]` 中。这个问题就转化为*如何求得 `b[0,y]` 所对应的最长匹配后缀子串*。此处，`y = next[i - 1]`。
	* 这里的叙述，可以从**可匹配**这个关键词来理解。

![[计算next数组示意图3.png]]

* 沿着这个思路，我们找到所有 `b[0, i - 1]` 的可匹配后缀子串 `b[y, i - 1]`, 直到找到一个可匹配的后缀子串，它对应的前缀子串下一个字符等于 `b[i]`. 此时的 `b[y, i]` 就是 `b[0, i]` 的最长可匹配后缀子串。

#### next (前缀表)数组的实现原理

* next 数组的计算，可以归纳为：
	* **设定初始值，首位记为 0，表示没有最长公共子串；**
	* 往后计算每一位字符所对应的最长公共子串，有两种场景，分别为当前字符和对应字符相等和不相等这两种：
		* **如果相等，就在原有的公共子串上长度加一，继续比较；**
		* **如果不等，就回退至上一个子串长度所对应索引的值，直到字符相等或已经回退到首位.**
			* **对应代码：`k = next[k - 1]`**

#### 失效函数的实现

* 下面是 Java 实现的代码，与上文的框架代码结合，就是基础的 KMP 算法的实现。

```java
// b表示模式串，m表示模式串的长度
private static int[] getNexts(char[] b, int m) {
  int[] next = new int[m];
  next[0] = -1;
  int k = -1;
  for (int i = 1; i < m; ++i) {
    while (k != -1 && b[k + 1] != b[i]) {
      k = next[k];
    }
    if (b[k + 1] == b[i]) {
      ++k;
    }
    next[i] = k;
  }
  return next;
}
```

* 下面是 TS 的实现。上面的代码用 -1 来表示不存在，这里我们用 0 来表示没有匹配的字符，本质上是一样的。TS 实现所得到的结果正好是上面结果的每一位加 1.
	* 示例代码中包括打印日志，可以直接执行查看效果。

```typescript
/**
 * @description: KMP 算法获取 next 数组
 * @param {string} s 模式串
 * @return {number[]}
 */
function getNext(s: string): number[] {
  let k = 0; // k 表示公共前缀子串的下标
	const len = s.length;
  const next: number[] = new Array(len);
  next[0] = 0; // 首位不需要移动

  for (let i = 1; i < len; i++) {
    // !如果不相同，就让前缀字符的下标位置回退比较，直到回退到 0 或者有相等字符为止
    while (k > 0 && s[i] !== s[k]) k = next[k - 1];
    // 如果下标位置的值相同，就保存 k 的值
    // 为什么这里加一次就够，因为其实如果上一个字符有公共匹配子串，那么 k 是不会重置的，可以继续使用
    if (s[i] === s[k]) k++;
    // 保存至数组下标中
    next[i] = k;
  }

  return next;
}

const str = 'ababac';
console.log(getNext(str)); // [ 0, 0, 1, 2, 3, 0 ]
```

* 上面是精简优化过后的代码，可能不太好理解，可以查看下面根据原始的思路一步步实现而成的代码。

```typescript
/**
 * @description: 创建 next 数组
 * @param {string} str
 * @param {number} len
 * @return {number[]}
 */
function createNext(str: string, len: number = str.length): number[] {
  let k = 0; // k 表示公共前缀子串的下标
  const next: number[] = new Array(len);
  next[0] = 0; // 首位不需要移动
  let i = 1;
  while (i < len) {
	  // 如果当前字符相等，就更新前缀表的值，值为 k 在原有基础上加 1
    if (str[i] === str[k]) {
      k++;
      next[i] = k;
      i++;
    } else {
      if (k > 0) {
        // !如果字符不相同，就让前缀字符的下标位置回退到上一位的位置的值，一直回退到值为 0 或者有相等的字符为止
        k = next[k - 1];
      } else {
        next[i] = k;
        i++;
      }
    }
    console.log('i is', i);
    console.log('k is', k);
    console.log('next is', next);
  }

  return next;
}
```

#### 失效函数的应用

* 在一部分 LeetCode 题目中有所应用。例如这一题，可以使用 `next` 数组来解。
	* [LeetCode-459](https://leetcode-cn.com/problems/repeated-substring-pattern/)
	* 注意：这道题用到的不是完整的 KMP 算法，而是 next 数组的实现。

### KMP 算法的完整实现与应用

* 结合上文的代码，我们梳理一版 TS 的完整实现。

```typescript
/**
 * @description: KMP 算法获取 next 数组
 * @param {string} s 模式串
 * @return {number[]}
 */
function getNext(s: string): number[] {
  let k = 0; // k 表示公共前缀子串的下标
  const len = s.length;
  const next: number[] = new Array(len);
  next[0] = 0; // 首位不需要移动

  for (let i = 1; i < len; i++) {
    // !如果不相同，就让前缀字符的下标位置回退比较，指向前一位长度作为下标所对应的值
    while (k > 0 && s[i] !== s[k]) k = next[k - 1];
    // 如果下标位置的值相同，就保存 k 的值
    // !为什么这里加一次就够，因为其实如果上一个字符有公共匹配子串，那么 k 是不会重置的，可以继续使用
    if (s[i] === s[k]) k++;
    // 保存至数组下标中
    next[i] = k;
  }

  return next;
}

/**
 * @description: KMP 算法实现
 * @param {string} str 主串
 * @param {string} s 模式串
 * @return {number}
 */
function kmp(str: string, s: string): number {
	if (s === '') return 0;
  const next = getNext(s); // 计算得到的 next 数组
  const len = str.length; // 保存主串长度
  const mLen = s.length; // 保存模式串长度
  let j = 0; // 当前已匹配的子串长度
  // 在主串中查找
  for (let i = 0; i < len; i++) {
    // 循环直到找到相等的第一个字符
    while (j > 0 && str[i] !== s[j]) {
      // 在整体右移的前缀表或称为 next 的实现里面，j = next[j]; 只是这一点不同而已
      j = next[j - 1];
    }

    // 相等的话就增加索引值，也就是继续查找
    if (str[i] === s[j]) {
      j++;
    }

    // 如果当前查找的子串长度等于模式串的长度，说明已经找到
    if (j === mLen) {
      return  i - mLen + 1;
    }
  }

  return -1;
}

const str = 'ababacfd';
console.log(kmp(str, 'bac')); // 3
console.log(kmp(str, 'ac')); // 4
console.log(kmp(str, 'f')); // 6
console.log(kmp(str, 'fc')); // -1
console.log(kmp(str, 'aba')); // 0
```

* 可以查看 LeetCode 的题解来理解 KMP 算法的应用。
	* [LeetCode-28](https://leetcode-cn.com/problems/implement-strstr/)：这道题就是 KMP 实现的应用。

## KMP 时间复杂度分析

### 空间复杂度

* KMP 的空间复杂度分析比较简单，因为只用到了 `next` 数组。`next` 的长度就是**模式串的长度 m**。所以 KMP 算法的空间复杂度就是 **`O(m)`**.

### 时间复杂度

* KMP 算法的实现包含两部分，第一部分是构建 `next` 数组，第二部分是借助 `next` 进行匹配。我们分别来分析时间复杂度。

#### 构建 next 数组的时间复杂度

* 计算 `next` 数组的代码中，外层的 `for` 循环从 `i = 1` 执行到 `i = m - 1`，执行次数 `m - 1` 次。同时 `for` 循环内有一个 `while` 循环。假设我们知道 `while` 循环的次数是 k，那么时间复杂度就是 `O(k * m)`. 然而 `while` 的循环次数比较难分析，于是不能用这种思路来预估。
* 可以直接用具体例子来思考，例如变量 i 和 k。i 从 1 开始一直增加到 `m - 1`，而 k 并不是每一次 `for` 循环都会增加，所以 k 的累加值肯定小于 m。而且 `while` 循环中 `k = next[k]`，实际是在减小 k 的值，k 累积增加都没有超过 m，所以 `while` 循环内 `k = next[k]` 总的执行次数也不可能超过 m。因此 next 数组的计算的时间复杂度是 `O(m)`.
	* 或者说，k 的值始终小于 m，甚至可以当作是常量来计算，这样的话常量作为系数可以忽略，那么时间复杂度也就是 O(m).

#### 匹配逻辑的时间复杂度

* 这部分分析的方法是类似的，i 从 0 循环增长到 `n - 1`，j 的增长量不可能超过 i，所以肯定小于 n。而且 `while` 循环中的语句 `j = next[j - 1] + 1`, 不会让 j 继续增长。
* j 的值也不可能维持不变，因为 `next[j - 1]` 的值肯定小于 `j - 1`，`while` 循环中的语句实际上也是在让 j 的值减少。j 总共增长的量不会超过 n，减少的量也不会超过n。因此 `while` 循环中这条语句总的执行次数也不会超过 n。这部分的时间复杂度是 `O(n)`.
* 综上所述，两部分时间复杂度合起来就是 `O(m+n)`. KMP 算法的时间复杂度就是 **`O(m+n)`**.

## KMP 算法的视频讲解

* KMP 算法的视频讲解其实是不少的，这里贴的是个人觉得比较简洁易懂，让自己比较好理解的两段视频。前者是讲解 KMP 的原理，后者是讲解 KMP 的代码实现。代码实现使用的是 C 语言，但逻辑上和 JS 是相通的。
* 注意在下面的视频实现里，计算 next 或说是前缀表的方式是整体右移一位，但其本质是相通的。只是最终在实现里 **`j = next[j - 1]` 和 `j = next[j]`** 的区别。

### KMP 算法原理的视频讲解

<iframe src="https://player.bilibili.com/player.html?bvid=BV1Px411z7Yo&p=4&cid=284638929&page=1&share_source=copy_web" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="520px"></iframe>

### KMP 算法实现的视频讲解

<iframe src="https://player.bilibili.com/player.html?bvid=BV1hW411a7ys&p=4&cid=284638929&page=1&share_source=copy_web" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="520px"></iframe>

## 小结

* 可以借助 BM 算法来理解 KMP 算法。核心思路其实就是理解好前缀规则。其中最难理解的部分是 `next` 数组的构建。本文讲述的是一种类似动态规划的思路来实现，由已经计算好的值来推导出后续的值。
* KMP 算法的时间复杂度是 `O(n+m)`, 分析的过程比较需要技巧，这里我们只需要理解，至于掌握并不强求。实际开发中，很少会遇到这样难以分析的代码。

#ALG 