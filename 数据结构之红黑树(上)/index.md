# 红黑树

## 简言

* 前面的章节我们分别学习了树，二叉树和二叉查找树。
* 二叉查找树是最常用的一种二叉树。它支持快速插入、删除和查找 操作，每个操作的时间复杂度和树的高度成正比。在理想情况下，时间复杂度是 `O(logn)`.
* 但是二叉查找树在频繁的动态更新中，可能会出现树的高度远大于 `log₂n` 的情况，从而导致各个操作的效率下降。甚至在极端情况下，二叉树会退化成链表，时间复杂度退化到 `O(n)`.
* 为了解决这个问题，需要设计一种平衡二叉查找树，也就是这一节主要关注的数据结构。

> 为什么工程中都喜欢使用红黑树，而不是其他平衡二叉查找树？
> 学习曲线：★★★☆

## 什么是平衡二叉查找树？

* 平衡二叉树的定义：**二叉树中任意一个节点的左右子树的高度相差不大于 1.**
* 上一节中的*完全二叉树和满二叉树都是平衡二叉树*，但是非完全二叉树也可能是平衡二叉树。

![[平衡二叉树示意图.png]]

* 而平衡二叉查找树不仅满足平衡二叉树的特点，也满足二叉查找树的特点。
* 最早的平衡二叉查找树是 [AVL树](https://www.wikiwand.com/zh/AVL%E6%A0%91)。
* 实际上，很多平衡二叉查找树并没有严格符合上面的定义（*树中任意一节点的左右子树的高度相差不大于 1*）。比如红黑树，从根节点到各个叶子节点的最长路径，可能会比最短路径大一倍。
	* *这里的定义有些奇怪，红黑树属于平衡二叉查找树，但又不严格符合它的定义。作者建议我们不用去抠细节。*
	* 而设计出平衡二叉查找树的初衷是为了解决问题，也就是解决**普通二叉查找树在频繁地插入、删除等动态更新的情况下，出现时间复杂度退化的问题。**
* 理解平衡二叉查找树中的“平衡”二字，是表示让整棵树看起来比较**均衡和对称**，树中的节点分布都比较均匀，这样树的高度不会太高，查找或删除等各类操作的效率也会高一些。
	* 这个时候不必追究是否严格遵守定义，也就是允许各个节点的高度差大于 1 的情况。

## 如何定义一棵红黑树

* 平衡二叉查找树其实有很多种。有伸展树(`Splay Tree`)，树堆(`Treap`)等。但是平时实际中听到的平衡二叉查找树，基本都是红黑树。甚至有的时候出现频率比平衡二叉查找树还高，导致默认提起平衡二叉查找树就是在提红黑树。
* **红黑树(Red-Black Tree)**，简称 `R-B Tree`，从定义上看，是不严格的平衡二叉查找树。
* **红黑树中的节点，一类标记为黑色，一类标记为红色**，然后还有以下几个要求：
	* **根节点是黑色的；**
	* **每个叶子节点都是黑色的空节点（Null），也就是说叶子节点不存储数据；**
	* **任何相邻的节点都不能同时为红色，红色节点会被黑色节点间隔开；**
	* **每个节点从该节点到达最远的叶子节点的所有路径，都包含相同数量的黑色节点。**
* 每个叶子节点都是黑色空节点这一特点是为了简化代码实现而设定的。在下一节学习红黑树的具体实现的时候会进一步了解。这节暂不考虑，因此下面的各张图中的黑色的空叶子节点就先省略。

![[红黑树示意图.png]]

### 为何说红黑树是近似平衡

* “平衡”可以理解为性能不退化。
* “近似平衡”可以理解为性能退化不明显或不严重。
* 二叉查找树的操作的性能和树的高度成正比，一颗极其平衡的二叉树（满二叉树或完全二叉树）的高度大概是 `logn₂n`. 因此如果要证明红黑树是近似平衡，只需要证明红黑树的高度是否比较稳定地趋近 `log₂n` 就好。
* 整个分析证明过程会比较复杂，我们一步一步进行。

#### 红黑树近似平衡的推导过程

* 首先，把红色节点从红黑树中清除，单纯包含黑色节点的红黑树的高度是多少呢？
* 红色节点删除之后，有些节点就没有父节点了，它们会拿这些节点的祖父节点作为父节点，所以之前的二叉树会变成**四叉树**。

![[红黑树近似平衡.png]]

* 前面红黑树中的定义有：**从任意节点到可达的叶子节点的每个路径都包含相同数目的黑色节点**。我们从四叉树中取出某些节点放到叶节点位置，四叉树就变成了完全二叉树。因此，仅包含黑色节点的四叉树的高度会比包含相同节点的完全二叉树的高度还要小。
	* 而完全二叉树的高度可以看作是近似 `log₂n`, 这里四叉黑树的高度低于完全二叉树，所以去掉红色节点的“黑树”的高度也不会超过 `log₂n`.
* 下面来观察一下把红色节点加回去后，树的高度会变成多少？
* 上面关于红黑树的定义中有，**红黑节点不能相邻**，也就是每有一个红色节点就至少要有一个黑色节点，黑色节点会把红色节点分隔开。
* 红黑树中黑色节点的路径不会超过 `log₂n`，所以加入红色节点之后，最长路径不会超过 `2log₂n`，也就是红黑树的高度近似 `2log₂n`.
* 相比之下，红黑树仅仅比高度平衡的 AVL 树的高度(`log₂n`) 大了一倍，在性能上，下降并不多。
* 这里的推导过程比较粗略，实际上红黑树的性能会更好一些。

## 红黑树的视频解析

* 这个视频的内容与本节是非常相似的，借助动画的方式更浅显易懂。其中有部分细节不够正确，可以当做辅助学习资料。

<iframe src="https://player.bilibili.com/player.html?bvid=BV1zU4y1H77f&cid=305015159&page=1&share_source=copy_web" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="520px"></iframe>

* 下面的视频是系列的第一篇，更为概括地介绍了红黑树。

<iframe src="https://player.bilibili.com/player.html?bvid=BV18y4y1m721&cid=283230416&page=1&share_source=copy_web" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="520px"></iframe>

## 小结

* 为什么在实际开发中，红黑树的应用会更加广泛？
* 因为前面提到的各种树结构，Treap，Splay Tree 在绝大部分情况下的操作效率都会很高，但也无法避免极端情况下时间复杂度的退化。尽管这种情况出现的几率并不大，但对于单次操作时间非常敏感的场景来说，它们并不适用。
* AVL 是高度平衡的二叉树，所以查找的效率非常高。但它为了维护平衡导致每次插入、删除都要做出调整，相应也就会更复杂，更耗时，这样就会牺牲效率。对于频繁插入和删除的数据集合，使用 AVL 树的代价就有些高昂。
	* **AVL 查找效率非常高，但是维护动态的平衡需要耗费很多性能。**
* 红黑树只是近似平衡，并不是严格平衡，因而在维护平衡的成本上也要比 AVL 树低一些。
* 综合而言，红黑树的插入、删除、查找等各种操作性能都比较稳定，对于工程应用来说，要面对各种异常情况，为了支撑工业级别的应用，我们更倾向于性能稳定的平衡二叉查找树，也即红黑树。

### 红黑树的学习思路

* 学习数据结构和算法，要学习它的由来、特性、适用场景和它解决的问题。
* 红黑树是一种平衡二叉查找树，它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。
* 红黑树的高度近似 `logn₂n`，所以是近似平衡，且它的插入、删除、查找的时间复杂度都是 `O(logn)`.
* 红黑树是一种性能非常稳定的二叉查找树，在实际工程中，只要用到动态插入、删除、查找数据的场景都可以用到它。但它的实现比较复杂，如果自己实现难度会非常高，这时更适合使用跳表来代替。

## 扩展

* 动态数据结构支持动态的数据插入、删除、查找操作 ，除了红黑树，前面还学习过哪些？可以一并比较各自的优劣势和应用场景。

#ALG #ADT 