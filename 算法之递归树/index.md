# 使用递归树来分析时间复杂度

## 简言

* 本节主要学习树这种数据结构的特殊应用，也就是递归树。
* 可以借助递归树来分析递归算法的时间复杂度。

> 学习曲线：★★★☆

## 递归树的定义

* 递归树是迭代计算的模型。
* 递归树的生成与迭代过程一致。
* 对递归树上的项求和就是迭代后方程的解。
* 递归树上所有项恰好是迭代之后产生和式的项。
* 这四个基本定义可以结合下文的视频来理解。

## 递归树与时间复杂度分析

* 把递归中一层一层的分解过程画成图，其实就是一棵树，称之为递归树。
* 下面是斐波那契数列的递归树的示意图。

![[递归树斐波那契数列.png]]
* 斐波那契数列的求和公式是：
	* `f(n) = f(n - 1) + f(n - 2)`

### 如何通过递归树来求解时间复杂度

* 我们来分析一下**归并排序**的时间复杂度。归并排序是借助递归算法实现的，每次都会一分为二进行排序。
* 下面是归并排序的递归树：

![[归并排序递归树.png]]

* 在归并算法中，每次一分为二的代价相对比较低，因此可以把时间消耗记作常量 1。这里就可以着重关注**合并的时间消耗**，也就是把两个子数组合并为大数组的时间消耗。
* 从上图中看，每一层归并操作消耗的时间总和是一样的，因为总是一分为二，所以合并的时候也是合并成所有数据，而且它其实和要排序的数据强关联。这里我们把每一层归并操作的时间消耗记作 n。
* 那么这里只要知道树的高度 h，就可以通过树的高度乘以每一层的时间消耗得到总的时间复杂度 `O(n * h)`.
* 从归并排序的原理和递归树可以观察到，**归并排序的递归树是一颗满二叉树*。而前面的章节提到，**满二叉树的高度是 `log₂n`.**
	* 所以**归并排序递归实现的时间复杂度就是 `O(nlogn)`.**
* 这里的时间复杂度的分析是估算的，并不十分精确，但实际不影响复杂度的计算结果。复杂度本身分析的就是整体的趋势。

## 实践分析

### 实践一：分析快速排序的时间复杂度

* 我们使用递归树来分析快速排序的平均时间复杂度。
* 取一个分区比较不平衡的场景来分析，这样比较有代表性。因为很难保证每次分区都维持平衡。
	* 例如一个分区是另一个分区的 9 倍。把递归过程画出来，就是下面这样的递归树：

![[快速排序递归树.png]]

* 快速排序的过程中，**每次分区都要遍历待分区区间的所有数据**。所以每一层分区操作所遍历的数据的个数之和就是 n。相当于每一层都要遍历一次所有数据。
* 类比上一个案例，那么时间复杂度就是 `O(h * n)`.
* 接下来就是求得树的高度 h。这里的递归树并不是满二叉树，所以不能和上面用同样的思路来理解。
* 快速排序结束的条件是待排序的区间个数小于等于 1. 翻译过来就是叶子节点的数据规模是 1. 从根节点 n 到叶子节点 1，递归树中最短的路径每次都乘以 1/10, 最长的路径每次都乘以 9/10。
* 通过计算可以得到根节点到叶子节点最短的路径是 `log₁₀n`,最长的路径是 `log(₁₀/₉)n`.

![[快速排序递归树分析.png]]

* 因此，遍历数据个数的总数就会介于  `nlog₁₀n` 和 `nlog(₁₀/₉)n` 之间。
* 根据复杂度的大 O 表示法，对数的底数不论都少都可以统一视为 `log₂n`.
* 上面分区 1 比 9 的时间复杂度就是 `nlogn.` 
* 类比如果分区是 1 比 99，得到的结果会是 `log₁₀₀n` 和 `log(₁₀₀/₉₉)n` 之间。这时尽管底数变了，但我们仍然可视为是 `nlogn`.
* 综合分析，分区的比例即使更夸张更巨大，只要比例 k 的值不随 n 变化，是可以确定的常量，那么快排的时间复杂度也不会变化，就是 `O(nlogn)`.

### 实践二：分析斐波那契数列的时间复杂度

* 前面递归的章节中，举的例子是跨台阶。实际上就是斐波那契数列。我们再重温一下代码实现:

```typescript
function f(n: number): number {
	if (n === 1) return 1;
	if (n === 2) return 2;
	return f(n - 1) + f(n - 2);
}
```

* 先把这段代码画成递归树：

![[斐波那契数列递归树.png]]

* 我们来分析这棵树的高度。`f(n)` 每一次都会分解为 `f(n - 1)` 和 `f(n - 2)`. 最终叶子的数据规模就是 1 或者 2. 因此从根节点到达叶子节点，每条路径的长短是不一的。
	* 如果每次 -1，那么路径长度就是 n，如果每次 -2，路径长度就是 n / 2.
* 每次分解之后的合并操作只需要一次加法运算，我们把这次加法运算的时间消耗记作常量 1. 从上往下看，第一层的总时间消耗是 1 ，第二层是 2，第三层是 2ˆ2，依次类推，第 k 层的时间消耗就是 `2ˆ(k-1)`. 总的算法消耗就会是每一层的时间消耗之和。
	* 如果路径长度都是 n，那么总和就是 `2ˆn - 1`.
	* 如果路径长度都是 n / 2, 那么时间消耗总和就是 `2ˆ(n/2) - 1`.

![[斐波那契数列时间复杂度分析1.png]]

![[斐波那契数列时间复杂度分析2.png]]

* 这样得到的结果就是时间复杂度介于 `O(2ˆn)` 和 `O(2ˆ(n/2))` 之间。这个结果有些宽泛，但也可以看出这个算法的复杂度是指数级的，非常高，属于较低效的算法。

### 实践三：分析全排列的时间复杂度

* 如何把 n 个数据的所有排列都找出来，这就是全排列的问题。
* 例如 1，2，3 这三个数据，可以有下面这几种不同的排列：

```shell
1, 2, 3
1, 3, 2,
2, 3, 1
2, 1, 3
3, 1, 2
3, 2, 1
```

* 可以通过递归的方式来打印出所有数据。
* 如果确定了最后一位数据，那么问题就转变成求解剩下 n - 1 个数据的排列问题。而最后一位数据可以是 n 个数据中的任意一个，因此最后一位取值有 n 种情况。
* 不考虑最后一位，问题就变为 n - 1 个数据的排列的情况；考虑最后一位，就是 n 种情况乘以 n - 1 个数字的排列问题。
	* **n 个数据的排列问题，可以分解为 n 个 n - 1 个数据的排列的子问题。**
* 转化成递推公式，就是下面这样的伪代码：

```shell
# 假设数组中存储的是1，2， 3...n。          
f(1,2,...n) = {最后一位是1, f(n-1)} + {最后一位是2, f(n-1)} +...+{最后一位是n, f(n-1)}。
```

* 转化为代码形式：

```java
// 调用方式：
// int[]a = a={1, 2, 3, 4}; printPermutations(a, 4, 4);
// k表示要处理的子数组的数据个数
public void printPermutations(int[] data, int n, int k) {
  if (k == 1) {
    for (int i = 0; i < n; ++i) {
      System.out.print(data[i] + " ");
    }
    System.out.println();
  }

  for (int i = 0; i < k; ++i) {
    int tmp = data[i];
    data[i] = data[k-1];
    data[k-1] = tmp;

    printPermutations(data, n, k - 1);

    tmp = data[i];
    data[i] = data[k-1];
    data[k-1] = tmp;
  }
}
```

* 用我们所熟悉的 TS 重写一遍：

```typescript
/**
 * @description: 打印出数组的全排列
 * let a = [1, 2, 3, 4]; printPermutations(a, 4, 4);
 * @param {number} data
 * @param {number} n
 * @param {number} k 表示要处理的子数组的数据个数，或者说要排列的前 k 个数
 * @return {void}
 */
function printPermutations(data: number[], n: number = data.length, k: number = data.length): void {
  if (k == 1) {
    for (let i = 0; i < n; ++i) {
      // console.log(data[i] + " ", 'num');
    }

    console.log(data)
  }

  for (let i = 0; i < k; ++i) {
    // 交换位置
    [data[k-1], data[i]] = [data[i], data[k-1]];
    
    printPermutations(data, n, k - 1);
    
    [data[i], data[k-1]] = [data[k-1], data[i]];
  }
}

printPermutations([1, 2, 3, 4], 4, 4);
printPermutations([7, 5, 3], 3, 3);
```

* 篇幅有限，打印的内容仅列出三个元素的数组 `[7, 5, 3]` 的全排列。

```shell
[ 5, 3, 7 ]
[ 3, 5, 7 ]
[ 3, 7, 5 ]
[ 7, 3, 5 ]
[ 5, 7, 3 ]
[ 7, 5, 3 ]
```

* 现在我们来借助递归树，分析出这段递归代码的时间复杂度。
* 首先还是画出递归树，但这棵树并不是标准的二叉树。

![[全排列的递归树.png]]

* 第一层分解有 n 次交换操作，第二层有 n 个节点，每个节点分解需要 n - 1 次交换，所以第二层的交换次数是 `n * (n - 1)`. 第三层有 `n * (n - 1) `个节点，每个节点分解需要 n - 2 次交换，所以第三层的交换次数是 `n * (n - 1) * (n - 2)`.
* 依次类推，第 k 层的总交换次数就是 `n * (n - 1) * (n - 2) * ... * (n - k + 1)`. 最后一层的交换次数就是 `n * (n - 1) * (n - 2) * (n - 3) * ... * 2 * 1`.
* 每一层的交换次数的总和就是总的交换次数。

```typescript
n + n*(n-1) + n*(n-1)*(n-2) +... + n*(n-1)*(n-2)*...*2*1
```

* 这个公式的求解比较复杂，但可以拆开来看。公式的最后一个乘积其实就是阶乘 `n!`. 而前面的每一个乘积都会小于最后一个，也就是肯定小于 `n * n!`，大于 `n!` 的.
	* **也就是全排列的时间复杂度是大于 `O(n!)` 的。**
* 通过这样的方式虽然不能精确求得时间复杂度，但可以确认全排列的时间复杂度是非常高的。
* 另外，**在分析时间复杂度的时候，核心的是分析过程中的思路，而不必太过于在乎求得十分精确的时间复杂度。**

## 递归树的视频讲解

* 可查到的有关递归树的视频讲解比较少，下面的这个视频作为补充帮助理解。

<iframe src="https://player.bilibili.com/player.html?bvid=BV16C4y1H7xi&cid=284638929&page=1&share_source=copy_web" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="520px"></iframe>

## 小结

* 这一节主要关注使用递归树分析时间复杂度。加上之前的使用递推公式推导时间复杂度的方法。目前学习了两种递归代码的时间复杂度分析。
* 具体的使用需要看两种分析方法的适用场景。例如归并排序和快速排序的最好时间复杂度，适合用递推公式来分析；而快速排序的平均时间复杂度适合用递归树来分析。当然也有两种都不适合的算法，例如二叉树递归的前中后序遍历。
* 时间复杂度的分析还是需要通过不断的练习和实践来提升和掌握。

## 扩展

* 1 个细胞的生命周期是 3 小时，每隔 1 小时分裂一次，求 n 小时后，容器内有多少细胞？
	* 使用递归时间复杂度的分析方法来分析这个递归问题的时间复杂度。
	* `2ˆn *  (2/3)` ? 计算公式存疑。💭

#ALG 